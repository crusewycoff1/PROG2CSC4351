Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "STRING_LITERAL" was declared but never used
Warning: Terminal "CHAR_LITERAL" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
  Filling in tables...
*** Shift/Reduce conflict found in state #263
  between selection_statement ::= IF LPAREN expression RPAREN statement (*) 
  and     selection_statement ::= IF LPAREN expression RPAREN statement (*) ELSE statement 
  under symbol ELSE
  Resolved in favor of shifting.

  Checking for non-reduced productions...
Writing parser...
===== Terminals =====
SHORT TIMES GT ARROW DIVASSIGN 
CONST GE PERIOD REGISTER ENUM 
RBRACK SIZEOF COMMA RBRACE RPAREN 
LBRACK LT INCREMENT SUBASSIGN DOUBLE 
BWISEANDASSIGN STRUCT LBRACE LPAREN MODASSIGN 
NOT TILDE LE VAR BITWISEAND 
FLOAT GOTO EQ LSHIFTASSIGN MODULUS 
LONG PLUS DIVIDE WHILE UNION 
ASSIGN CHAR ADDASSIGN DO FOR 
VOID EXTERN RETURN ELSE BREAK 
FUN INT STRING_LITERAL EOF SEMICOLON 
MULASSIGN ELIPSES DECREMENT MINUS OR 
error DECIMAL_LITERAL CONTINUE IF BWISEOR 
ID COLON BWISEXOR BWISEORASSIGN RSHIFTASSIGN 
VOLATILE CHAR_LITERAL RSHIFT BWISEXORASSIGN NEQ 
AND STATIC LSHIFT TYPEDEF AUTO 


===== Non terminals =====
bitfield_list struct_declaration_list declaration_list initializer pointer_list 
additive_expression iteration_statement enumerator $START jump_statement 
Var compound_statement initializer_list constant_expression initialization 
struct_or_union primary_expression name argument_expression_list logical_or_expression 
equality_expression exclusive_or_expression cast_expression expression_array_type_list bitfield_value 
enumerator_list parameter_type_list expression type_parameters statement 
unary_expression empty_array_type_list brackets_list selection_statement conditional_expression 
type_name postfix_expression logical_and_expression shift_expression and_expression 
parameter_list empty_array_type expression_array_type inclusive_or_expression assignment_expression 
type_augments multiplicative_expression expression_statement parameters struct_or_union_declarator 
declaration relational_expression labeled_statement statement_list type 


===== Productions =====
jump_statement ::= RETURN SEMICOLON 
jump_statement ::= RETURN expression SEMICOLON 
jump_statement ::= BREAK SEMICOLON 
jump_statement ::= CONTINUE SEMICOLON 
jump_statement ::= GOTO Var SEMICOLON 
iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement 
iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement 
iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON RPAREN statement 
iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement 
iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement 
iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement 
iteration_statement ::= DO statement WHILE LPAREN expression RPAREN SEMICOLON 
iteration_statement ::= WHILE LPAREN expression RPAREN statement 
selection_statement ::= IF LPAREN expression RPAREN statement ELSE statement 
selection_statement ::= IF LPAREN expression RPAREN statement 
expression_statement ::= SEMICOLON 
expression_statement ::= expression SEMICOLON 
statement_list ::= statement_list statement 
statement_list ::= statement 
compound_statement ::= LBRACE RBRACE 
compound_statement ::= LBRACE declaration_list RBRACE 
compound_statement ::= LBRACE statement_list RBRACE 
compound_statement ::= LBRACE declaration_list statement_list RBRACE 
labeled_statement ::= Var COLON statement 
statement ::= jump_statement 
statement ::= iteration_statement 
statement ::= selection_statement 
statement ::= expression_statement 
statement ::= compound_statement 
statement ::= labeled_statement 
Var ::= ID 
expression ::= expression COMMA assignment_expression 
expression ::= assignment_expression 
assignment_expression ::= unary_expression RSHIFTASSIGN assignment_expression 
assignment_expression ::= unary_expression LSHIFTASSIGN assignment_expression 
assignment_expression ::= unary_expression BWISEXORASSIGN assignment_expression 
assignment_expression ::= unary_expression BWISEORASSIGN assignment_expression 
assignment_expression ::= unary_expression BWISEANDASSIGN assignment_expression 
assignment_expression ::= unary_expression MODASSIGN assignment_expression 
assignment_expression ::= unary_expression MULASSIGN assignment_expression 
assignment_expression ::= unary_expression DIVASSIGN assignment_expression 
assignment_expression ::= unary_expression SUBASSIGN assignment_expression 
assignment_expression ::= unary_expression ADDASSIGN assignment_expression 
assignment_expression ::= unary_expression ASSIGN assignment_expression 
assignment_expression ::= conditional_expression 
constant_expression ::= conditional_expression 
conditional_expression ::= logical_or_expression 
logical_or_expression ::= logical_or_expression OR logical_and_expression 
logical_or_expression ::= logical_and_expression 
logical_and_expression ::= logical_and_expression AND inclusive_or_expression 
logical_and_expression ::= inclusive_or_expression 
inclusive_or_expression ::= inclusive_or_expression BWISEOR exclusive_or_expression 
inclusive_or_expression ::= exclusive_or_expression 
exclusive_or_expression ::= and_expression BWISEXOR equality_expression 
exclusive_or_expression ::= and_expression 
and_expression ::= and_expression BITWISEAND equality_expression 
and_expression ::= equality_expression 
equality_expression ::= equality_expression NEQ relational_expression 
equality_expression ::= equality_expression EQ relational_expression 
equality_expression ::= relational_expression 
relational_expression ::= relational_expression LT shift_expression 
relational_expression ::= relational_expression LE shift_expression 
relational_expression ::= relational_expression GT shift_expression 
relational_expression ::= relational_expression GE shift_expression 
relational_expression ::= shift_expression 
shift_expression ::= shift_expression LSHIFT additive_expression 
shift_expression ::= shift_expression RSHIFT additive_expression 
shift_expression ::= additive_expression 
additive_expression ::= additive_expression MINUS multiplicative_expression 
additive_expression ::= additive_expression PLUS multiplicative_expression 
additive_expression ::= multiplicative_expression 
multiplicative_expression ::= multiplicative_expression MODULUS cast_expression 
multiplicative_expression ::= multiplicative_expression DIVIDE cast_expression 
multiplicative_expression ::= multiplicative_expression TIMES cast_expression 
multiplicative_expression ::= cast_expression 
cast_expression ::= unary_expression 
unary_expression ::= SIZEOF LPAREN type_name RPAREN 
unary_expression ::= NOT cast_expression 
unary_expression ::= TILDE cast_expression 
unary_expression ::= MINUS cast_expression 
unary_expression ::= PLUS cast_expression 
unary_expression ::= DECREMENT unary_expression 
unary_expression ::= INCREMENT unary_expression 
unary_expression ::= postfix_expression 
argument_expression_list ::= argument_expression_list COMMA assignment_expression 
argument_expression_list ::= assignment_expression 
postfix_expression ::= postfix_expression ARROW Var 
postfix_expression ::= postfix_expression PERIOD Var 
postfix_expression ::= postfix_expression DECREMENT 
postfix_expression ::= postfix_expression INCREMENT 
postfix_expression ::= postfix_expression LPAREN RPAREN 
postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN 
postfix_expression ::= postfix_expression LBRACK expression RBRACK 
postfix_expression ::= primary_expression 
primary_expression ::= LPAREN expression RPAREN 
primary_expression ::= DECIMAL_LITERAL 
primary_expression ::= Var 
primary_expression ::= error 
initializer ::= LBRACE initializer_list RBRACE 
initializer ::= assignment_expression 
initializer_list ::= initializer_list COMMA initializer 
initializer_list ::= initializer 
parameter_type_list ::= parameter_type_list COMMA type 
parameter_type_list ::= type 
parameter_list ::= parameter_list COMMA type name 
parameter_list ::= type name 
parameters ::= LPAREN RPAREN 
parameters ::= LPAREN parameter_list COMMA ELIPSES RPAREN 
parameters ::= LPAREN parameter_list RPAREN 
type_parameters ::= LPAREN RPAREN 
type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES RPAREN 
type_parameters ::= LPAREN parameter_type_list RPAREN 
struct_or_union ::= UNION 
struct_or_union ::= STRUCT 
struct_declaration_list ::= struct_declaration_list type name SEMICOLON 
struct_declaration_list ::= type name SEMICOLON 
enumerator ::= ID ASSIGN constant_expression 
enumerator ::= ID 
enumerator_list ::= enumerator_list COMMA enumerator 
enumerator_list ::= enumerator 
struct_or_union_declarator ::= LBRACE struct_declaration_list RBRACE 
initialization ::= ASSIGN initializer 
type_name ::= ID 
type_name ::= ENUM ID 
type_name ::= DOUBLE 
type_name ::= FLOAT 
type_name ::= LONG 
type_name ::= INT 
type_name ::= SHORT 
type_name ::= CHAR 
type_name ::= VOID 
pointer_list ::= pointer_list TIMES 
pointer_list ::= TIMES 
brackets_list ::= expression_array_type_list 
brackets_list ::= empty_array_type_list 
type_augments ::= pointer_list brackets_list 
type_augments ::= brackets_list 
type_augments ::= pointer_list 
type ::= type_name 
type ::= type_name type_augments 
expression_array_type ::= LBRACK constant_expression RBRACK 
expression_array_type_list ::= expression_array_type_list expression_array_type 
expression_array_type_list ::= expression_array_type 
empty_array_type ::= LBRACK RBRACK 
empty_array_type_list ::= empty_array_type_list empty_array_type 
empty_array_type_list ::= empty_array_type 
bitfield_value ::= REGISTER 
bitfield_value ::= AUTO 
bitfield_value ::= STATIC 
bitfield_value ::= EXTERN 
bitfield_value ::= VOLATILE 
bitfield_value ::= CONST 
bitfield_list ::= bitfield_value bitfield_list 
bitfield_list ::= 
name ::= ID 
declaration ::= ENUM ID LBRACE enumerator_list RBRACE 
declaration ::= bitfield_list struct_or_union name struct_or_union_declarator 
declaration ::= TYPEDEF type name SEMICOLON 
declaration ::= FUN bitfield_list type name type_parameters SEMICOLON 
declaration ::= FUN bitfield_list type name parameters compound_statement 
declaration ::= VAR bitfield_list type name initialization SEMICOLON 
declaration_list ::= declaration 
declaration_list ::= declaration_list declaration 
$START ::= declaration_list EOF 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration_list ::= (*) declaration , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration_list ::= (*) declaration_list declaration , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [declaration ::= (*) TYPEDEF type name SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [$START ::= (*) declaration_list EOF , {EOF }]
}
transition on CONST to state [14]
transition on AUTO to state [13]
transition on bitfield_list to state [12]
transition on bitfield_value to state [11]
transition on declaration_list to state [10]
transition on VOLATILE to state [9]
transition on EXTERN to state [8]
transition on TYPEDEF to state [7]
transition on VAR to state [6]
transition on REGISTER to state [5]
transition on FUN to state [4]
transition on declaration to state [3]
transition on STATIC to state [2]
transition on ENUM to state [1]

-------------------
lalr_state [1]: {
  [declaration ::= ENUM (*) ID LBRACE enumerator_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on ID to state [298]

-------------------
lalr_state [2]: {
  [bitfield_value ::= STATIC (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [3]: {
  [declaration_list ::= declaration (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [4]: {
  [bitfield_value ::= (*) REGISTER , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) EXTERN , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [declaration ::= FUN (*) bitfield_list type name type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [bitfield_value ::= (*) AUTO , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) VOLATILE , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [declaration ::= FUN (*) bitfield_list type name parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [bitfield_value ::= (*) STATIC , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) CONST , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}
transition on bitfield_value to state [11]
transition on EXTERN to state [8]
transition on AUTO to state [13]
transition on REGISTER to state [5]
transition on bitfield_list to state [196]
transition on STATIC to state [2]
transition on VOLATILE to state [9]
transition on CONST to state [14]

-------------------
lalr_state [5]: {
  [bitfield_value ::= REGISTER (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [6]: {
  [bitfield_value ::= (*) REGISTER , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) EXTERN , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) AUTO , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) VOLATILE , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) STATIC , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) CONST , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [declaration ::= VAR (*) bitfield_list type name initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on bitfield_value to state [11]
transition on EXTERN to state [8]
transition on AUTO to state [13]
transition on REGISTER to state [5]
transition on STATIC to state [2]
transition on bitfield_list to state [182]
transition on VOLATILE to state [9]
transition on CONST to state [14]

-------------------
lalr_state [7]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [declaration ::= TYPEDEF (*) type name SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on type to state [179]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [8]: {
  [bitfield_value ::= EXTERN (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [9]: {
  [bitfield_value ::= VOLATILE (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [10]: {
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration_list ::= declaration_list (*) declaration , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [declaration ::= (*) TYPEDEF type name SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [$START ::= declaration_list (*) EOF , {EOF }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
}
transition on CONST to state [14]
transition on bitfield_list to state [12]
transition on AUTO to state [13]
transition on bitfield_value to state [11]
transition on VOLATILE to state [9]
transition on EXTERN to state [8]
transition on TYPEDEF to state [7]
transition on VAR to state [6]
transition on EOF to state [178]
transition on REGISTER to state [5]
transition on FUN to state [4]
transition on declaration to state [177]
transition on STATIC to state [2]
transition on ENUM to state [1]

-------------------
lalr_state [11]: {
  [bitfield_value ::= (*) REGISTER , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= bitfield_value (*) bitfield_list , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) EXTERN , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) AUTO , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) VOLATILE , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) STATIC , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) CONST , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}
transition on bitfield_value to state [11]
transition on EXTERN to state [8]
transition on AUTO to state [13]
transition on REGISTER to state [5]
transition on bitfield_list to state [176]
transition on STATIC to state [2]
transition on VOLATILE to state [9]
transition on CONST to state [14]

-------------------
lalr_state [12]: {
  [declaration ::= bitfield_list (*) struct_or_union name struct_or_union_declarator , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [struct_or_union ::= (*) UNION , {ID }]
  [struct_or_union ::= (*) STRUCT , {ID }]
}
transition on UNION to state [17]
transition on STRUCT to state [16]
transition on struct_or_union to state [15]

-------------------
lalr_state [13]: {
  [bitfield_value ::= AUTO (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [14]: {
  [bitfield_value ::= CONST (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [15]: {
  [declaration ::= bitfield_list struct_or_union (*) name struct_or_union_declarator , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) ID , {LBRACE }]
}
transition on name to state [19]
transition on ID to state [18]

-------------------
lalr_state [16]: {
  [struct_or_union ::= STRUCT (*) , {ID }]
}

-------------------
lalr_state [17]: {
  [struct_or_union ::= UNION (*) , {ID }]
}

-------------------
lalr_state [18]: {
  [name ::= ID (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACE ASSIGN }]
}

-------------------
lalr_state [19]: {
  [declaration ::= bitfield_list struct_or_union name (*) struct_or_union_declarator , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [struct_or_union_declarator ::= (*) LBRACE struct_declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on struct_or_union_declarator to state [21]
transition on LBRACE to state [20]

-------------------
lalr_state [20]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [struct_declaration_list ::= (*) type name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [struct_declaration_list ::= (*) struct_declaration_list type name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [struct_or_union_declarator ::= LBRACE (*) struct_declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on type to state [30]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on struct_declaration_list to state [27]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [21]: {
  [declaration ::= bitfield_list struct_or_union name struct_or_union_declarator (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [22]: {
  [type_name ::= ENUM (*) ID , {ID COMMA RPAREN LBRACK TIMES }]
}
transition on ID to state [175]

-------------------
lalr_state [23]: {
  [type_name ::= INT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [24]: {
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= (*) TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [type ::= type_name (*) , {ID COMMA RPAREN }]
  [type_augments ::= (*) pointer_list brackets_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type_list expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type_list empty_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= (*) expression_array_type_list , {ID COMMA RPAREN }]
  [type ::= type_name (*) type_augments , {ID COMMA RPAREN }]
  [type_augments ::= (*) brackets_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= (*) pointer_list TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [brackets_list ::= (*) empty_array_type_list , {ID COMMA RPAREN }]
  [type_augments ::= (*) pointer_list , {ID COMMA RPAREN }]
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on LBRACK to state [48]
transition on TIMES to state [47]
transition on empty_array_type_list to state [46]
transition on expression_array_type_list to state [45]
transition on brackets_list to state [44]
transition on type_augments to state [43]
transition on expression_array_type to state [42]
transition on pointer_list to state [41]
transition on empty_array_type to state [40]

-------------------
lalr_state [25]: {
  [type_name ::= LONG (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [26]: {
  [type_name ::= VOID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [27]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [struct_declaration_list ::= struct_declaration_list (*) type name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [struct_or_union_declarator ::= LBRACE struct_declaration_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on RBRACE to state [37]
transition on type to state [36]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [28]: {
  [type_name ::= DOUBLE (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [29]: {
  [type_name ::= ID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [30]: {
  [struct_declaration_list ::= type (*) name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [name ::= (*) ID , {SEMICOLON }]
}
transition on name to state [34]
transition on ID to state [18]

-------------------
lalr_state [31]: {
  [type_name ::= SHORT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [32]: {
  [type_name ::= FLOAT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [33]: {
  [type_name ::= CHAR (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [34]: {
  [struct_declaration_list ::= type name (*) SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}
transition on SEMICOLON to state [35]

-------------------
lalr_state [35]: {
  [struct_declaration_list ::= type name SEMICOLON (*) , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}

-------------------
lalr_state [36]: {
  [name ::= (*) ID , {SEMICOLON }]
  [struct_declaration_list ::= struct_declaration_list type (*) name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}
transition on name to state [38]
transition on ID to state [18]

-------------------
lalr_state [37]: {
  [struct_or_union_declarator ::= LBRACE struct_declaration_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [38]: {
  [struct_declaration_list ::= struct_declaration_list type name (*) SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}
transition on SEMICOLON to state [39]

-------------------
lalr_state [39]: {
  [struct_declaration_list ::= struct_declaration_list type name SEMICOLON (*) , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}

-------------------
lalr_state [40]: {
  [empty_array_type_list ::= empty_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [41]: {
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [type_augments ::= pointer_list (*) brackets_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type_list expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type_list empty_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= (*) expression_array_type_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= pointer_list (*) TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [type_augments ::= pointer_list (*) , {ID COMMA RPAREN }]
  [brackets_list ::= (*) empty_array_type_list , {ID COMMA RPAREN }]
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on expression_array_type_list to state [45]
transition on TIMES to state [174]
transition on empty_array_type to state [40]
transition on LBRACK to state [48]
transition on expression_array_type to state [42]
transition on brackets_list to state [173]
transition on empty_array_type_list to state [46]

-------------------
lalr_state [42]: {
  [expression_array_type_list ::= expression_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [43]: {
  [type ::= type_name type_augments (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [44]: {
  [type_augments ::= brackets_list (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [45]: {
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [expression_array_type_list ::= expression_array_type_list (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= expression_array_type_list (*) , {ID COMMA RPAREN }]
}
transition on LBRACK to state [172]
transition on expression_array_type to state [171]

-------------------
lalr_state [46]: {
  [brackets_list ::= empty_array_type_list (*) , {ID COMMA RPAREN }]
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= empty_array_type_list (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
}
transition on empty_array_type to state [170]
transition on LBRACK to state [169]

-------------------
lalr_state [47]: {
  [pointer_list ::= TIMES (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [48]: {
  [unary_expression ::= (*) NOT cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression_array_type ::= LBRACK (*) constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [constant_expression ::= (*) conditional_expression , {RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [empty_array_type ::= LBRACK (*) RBRACK , {ID COMMA RPAREN LBRACK }]
  [logical_or_expression ::= (*) logical_and_expression , {RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {RBRACK OR }]
  [and_expression ::= (*) equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [conditional_expression ::= (*) logical_or_expression , {RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on constant_expression to state [77]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [61]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]
transition on RBRACK to state [49]

-------------------
lalr_state [49]: {
  [empty_array_type ::= LBRACK RBRACK (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [50]: {
  [unary_expression ::= SIZEOF (*) LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on LPAREN to state [166]

-------------------
lalr_state [51]: {
  [postfix_expression ::= primary_expression (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [52]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= PLUS (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [165]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [53]: {
  [primary_expression ::= Var (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [54]: {
  [multiplicative_expression ::= cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [55]: {
  [primary_expression ::= DECIMAL_LITERAL (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [56]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= NOT (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [164]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [57]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= DECREMENT (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [163]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [58]: {
  [cast_expression ::= unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [59]: {
  [exclusive_or_expression ::= and_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [and_expression ::= and_expression (*) BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [exclusive_or_expression ::= and_expression (*) BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
}
transition on BWISEXOR to state [160]
transition on BITWISEAND to state [159]

-------------------
lalr_state [60]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= LPAREN (*) expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [157]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [61]: {
  [constant_expression ::= conditional_expression (*) , {COMMA RBRACK RBRACE }]
}

-------------------
lalr_state [62]: {
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [102]
transition on LSHIFT to state [101]

-------------------
lalr_state [63]: {
  [Var ::= ID (*) , {COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [64]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= TILDE (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [156]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [65]: {
  [postfix_expression ::= postfix_expression (*) LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= postfix_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on PERIOD to state [118]
transition on LPAREN to state [117]
transition on ARROW to state [116]
transition on INCREMENT to state [115]
transition on LBRACK to state [114]
transition on DECREMENT to state [113]

-------------------
lalr_state [66]: {
  [inclusive_or_expression ::= exclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
}

-------------------
lalr_state [67]: {
  [inclusive_or_expression ::= inclusive_or_expression (*) BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [logical_and_expression ::= inclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
}
transition on BWISEOR to state [89]

-------------------
lalr_state [68]: {
  [additive_expression ::= additive_expression (*) MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= additive_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on MINUS to state [105]
transition on PLUS to state [104]

-------------------
lalr_state [69]: {
  [equality_expression ::= relational_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on GE to state [99]
transition on LE to state [98]
transition on GT to state [97]
transition on LT to state [96]

-------------------
lalr_state [70]: {
  [equality_expression ::= equality_expression (*) NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression (*) EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [and_expression ::= equality_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on NEQ to state [94]
transition on EQ to state [93]

-------------------
lalr_state [71]: {
  [logical_or_expression ::= logical_and_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [logical_and_expression ::= logical_and_expression (*) AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
}
transition on AND to state [87]

-------------------
lalr_state [72]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= INCREMENT (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [92]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [73]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= MINUS (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [91]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [74]: {
  [primary_expression ::= error (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [75]: {
  [conditional_expression ::= logical_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= logical_or_expression (*) OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
}
transition on OR to state [85]

-------------------
lalr_state [76]: {
  [additive_expression ::= multiplicative_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= multiplicative_expression (*) TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on TIMES to state [81]
transition on MODULUS to state [80]
transition on DIVIDE to state [79]

-------------------
lalr_state [77]: {
  [expression_array_type ::= LBRACK constant_expression (*) RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on RBRACK to state [78]

-------------------
lalr_state [78]: {
  [expression_array_type ::= LBRACK constant_expression RBRACK (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [79]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression DIVIDE (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [84]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [80]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression MODULUS (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [83]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [81]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression TIMES (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [82]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [82]: {
  [multiplicative_expression ::= multiplicative_expression TIMES cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [83]: {
  [multiplicative_expression ::= multiplicative_expression MODULUS cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [84]: {
  [multiplicative_expression ::= multiplicative_expression DIVIDE cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [85]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= logical_or_expression OR (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [86]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [86]: {
  [logical_and_expression ::= logical_and_expression (*) AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [logical_or_expression ::= logical_or_expression OR logical_and_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
}
transition on AND to state [87]

-------------------
lalr_state [87]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= logical_and_expression AND (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [88]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [88]: {
  [inclusive_or_expression ::= inclusive_or_expression (*) BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [logical_and_expression ::= logical_and_expression AND inclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
}
transition on BWISEOR to state [89]

-------------------
lalr_state [89]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= inclusive_or_expression BWISEOR (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on exclusive_or_expression to state [90]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [90]: {
  [inclusive_or_expression ::= inclusive_or_expression BWISEOR exclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
}

-------------------
lalr_state [91]: {
  [unary_expression ::= MINUS cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [92]: {
  [unary_expression ::= INCREMENT unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [93]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= equality_expression EQ (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [112]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [94]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= equality_expression NEQ (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [95]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [95]: {
  [equality_expression ::= equality_expression NEQ relational_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on GE to state [99]
transition on LE to state [98]
transition on GT to state [97]
transition on LT to state [96]

-------------------
lalr_state [96]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression LT (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [111]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [97]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [relational_expression ::= relational_expression GT (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [110]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [98]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [relational_expression ::= relational_expression LE (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [109]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [99]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [relational_expression ::= relational_expression GE (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [100]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [100]: {
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression GE shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [102]
transition on LSHIFT to state [101]

-------------------
lalr_state [101]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= shift_expression LSHIFT (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [108]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [102]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= shift_expression RSHIFT (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [103]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [103]: {
  [additive_expression ::= additive_expression (*) MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression RSHIFT additive_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on MINUS to state [105]
transition on PLUS to state [104]

-------------------
lalr_state [104]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression PLUS (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on multiplicative_expression to state [107]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [54]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [105]: {
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression MINUS (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [53]
transition on LPAREN to state [60]
transition on primary_expression to state [51]
transition on multiplicative_expression to state [106]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on error to state [74]
transition on ID to state [63]
transition on DECREMENT to state [57]
transition on cast_expression to state [54]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [52]
transition on unary_expression to state [58]
transition on SIZEOF to state [50]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [106]: {
  [multiplicative_expression ::= multiplicative_expression (*) TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression MINUS multiplicative_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= multiplicative_expression (*) MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on TIMES to state [81]
transition on MODULUS to state [80]
transition on DIVIDE to state [79]

-------------------
lalr_state [107]: {
  [multiplicative_expression ::= multiplicative_expression (*) TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression PLUS multiplicative_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= multiplicative_expression (*) DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on TIMES to state [81]
transition on MODULUS to state [80]
transition on DIVIDE to state [79]

-------------------
lalr_state [108]: {
  [shift_expression ::= shift_expression LSHIFT additive_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on MINUS to state [105]
transition on PLUS to state [104]

-------------------
lalr_state [109]: {
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression LE shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [102]
transition on LSHIFT to state [101]

-------------------
lalr_state [110]: {
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression GT shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [102]
transition on LSHIFT to state [101]

-------------------
lalr_state [111]: {
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression LT shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [102]
transition on LSHIFT to state [101]

-------------------
lalr_state [112]: {
  [relational_expression ::= relational_expression (*) GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression EQ relational_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on GE to state [99]
transition on LE to state [98]
transition on GT to state [97]
transition on LT to state [96]

-------------------
lalr_state [113]: {
  [postfix_expression ::= postfix_expression DECREMENT (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [114]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACK }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RBRACK }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACK OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression LBRACK (*) expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RBRACK }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RBRACK }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [152]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [115]: {
  [postfix_expression ::= postfix_expression INCREMENT (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [116]: {
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression ARROW (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on Var to state [150]
transition on ID to state [63]

-------------------
lalr_state [117]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression LPAREN (*) RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [argument_expression_list ::= (*) assignment_expression , {COMMA RPAREN }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [argument_expression_list ::= (*) argument_expression_list COMMA assignment_expression , {COMMA RPAREN }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression LPAREN (*) argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on argument_expression_list to state [124]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [121]
transition on RPAREN to state [120]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [118]: {
  [postfix_expression ::= postfix_expression PERIOD (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on Var to state [119]
transition on ID to state [63]

-------------------
lalr_state [119]: {
  [postfix_expression ::= postfix_expression PERIOD Var (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [120]: {
  [postfix_expression ::= postfix_expression LPAREN RPAREN (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [121]: {
  [argument_expression_list ::= assignment_expression (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [122]: {
  [assignment_expression ::= unary_expression (*) LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [cast_expression ::= unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression (*) BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}
transition on MODASSIGN to state [138]
transition on DIVASSIGN to state [137]
transition on RSHIFTASSIGN to state [136]
transition on ASSIGN to state [135]
transition on BWISEXORASSIGN to state [134]
transition on ADDASSIGN to state [133]
transition on LSHIFTASSIGN to state [132]
transition on SUBASSIGN to state [131]
transition on BWISEORASSIGN to state [130]
transition on BWISEANDASSIGN to state [129]
transition on MULASSIGN to state [128]

-------------------
lalr_state [123]: {
  [assignment_expression ::= conditional_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [124]: {
  [argument_expression_list ::= argument_expression_list (*) COMMA assignment_expression , {COMMA RPAREN }]
  [postfix_expression ::= postfix_expression LPAREN argument_expression_list (*) RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on RPAREN to state [126]
transition on COMMA to state [125]

-------------------
lalr_state [125]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [argument_expression_list ::= argument_expression_list COMMA (*) assignment_expression , {COMMA RPAREN }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [127]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [126]: {
  [postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [127]: {
  [argument_expression_list ::= argument_expression_list COMMA assignment_expression (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [128]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression MULASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [149]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [129]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression BWISEANDASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [148]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [130]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression BWISEORASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [147]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [131]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression SUBASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [146]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [132]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression LSHIFTASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [145]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [133]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression ADDASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [144]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [134]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression BWISEXORASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [143]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [135]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression ASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [142]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [136]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression RSHIFTASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [141]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [137]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression DIVASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [140]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [138]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression MODASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [139]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [139]: {
  [assignment_expression ::= unary_expression MODASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [140]: {
  [assignment_expression ::= unary_expression DIVASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [141]: {
  [assignment_expression ::= unary_expression RSHIFTASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [142]: {
  [assignment_expression ::= unary_expression ASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [143]: {
  [assignment_expression ::= unary_expression BWISEXORASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [144]: {
  [assignment_expression ::= unary_expression ADDASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [145]: {
  [assignment_expression ::= unary_expression LSHIFTASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [146]: {
  [assignment_expression ::= unary_expression SUBASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [147]: {
  [assignment_expression ::= unary_expression BWISEORASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [148]: {
  [assignment_expression ::= unary_expression BWISEANDASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [149]: {
  [assignment_expression ::= unary_expression MULASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [150]: {
  [postfix_expression ::= postfix_expression ARROW Var (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [151]: {
  [expression ::= assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK }]
}

-------------------
lalr_state [152]: {
  [postfix_expression ::= postfix_expression LBRACK expression (*) RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RBRACK }]
}
transition on RBRACK to state [154]
transition on COMMA to state [153]

-------------------
lalr_state [153]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= expression COMMA (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [155]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [154]: {
  [postfix_expression ::= postfix_expression LBRACK expression RBRACK (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [155]: {
  [expression ::= expression COMMA assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK }]
}

-------------------
lalr_state [156]: {
  [unary_expression ::= TILDE cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [157]: {
  [primary_expression ::= LPAREN expression (*) RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [158]
transition on COMMA to state [153]

-------------------
lalr_state [158]: {
  [primary_expression ::= LPAREN expression RPAREN (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [159]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= and_expression BITWISEAND (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [162]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [160]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [exclusive_or_expression ::= and_expression BWISEXOR (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [161]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on LPAREN to state [60]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [161]: {
  [equality_expression ::= equality_expression (*) NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [exclusive_or_expression ::= and_expression BWISEXOR equality_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [equality_expression ::= equality_expression (*) EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
}
transition on NEQ to state [94]
transition on EQ to state [93]

-------------------
lalr_state [162]: {
  [equality_expression ::= equality_expression (*) NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [and_expression ::= and_expression BITWISEAND equality_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression (*) EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on NEQ to state [94]
transition on EQ to state [93]

-------------------
lalr_state [163]: {
  [unary_expression ::= DECREMENT unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [164]: {
  [unary_expression ::= NOT cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [165]: {
  [unary_expression ::= PLUS cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [166]: {
  [type_name ::= (*) ENUM ID , {RPAREN }]
  [type_name ::= (*) LONG , {RPAREN }]
  [type_name ::= (*) CHAR , {RPAREN }]
  [type_name ::= (*) DOUBLE , {RPAREN }]
  [type_name ::= (*) INT , {RPAREN }]
  [type_name ::= (*) VOID , {RPAREN }]
  [unary_expression ::= SIZEOF LPAREN (*) type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [type_name ::= (*) ID , {RPAREN }]
  [type_name ::= (*) FLOAT , {RPAREN }]
  [type_name ::= (*) SHORT , {RPAREN }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [167]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [167]: {
  [unary_expression ::= SIZEOF LPAREN type_name (*) RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on RPAREN to state [168]

-------------------
lalr_state [168]: {
  [unary_expression ::= SIZEOF LPAREN type_name RPAREN (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [169]: {
  [empty_array_type ::= LBRACK (*) RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on RBRACK to state [49]

-------------------
lalr_state [170]: {
  [empty_array_type_list ::= empty_array_type_list empty_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [171]: {
  [expression_array_type_list ::= expression_array_type_list expression_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [172]: {
  [unary_expression ::= (*) NOT cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression_array_type ::= LBRACK (*) constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [constant_expression ::= (*) conditional_expression , {RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_and_expression , {RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {RBRACK OR }]
  [and_expression ::= (*) equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [conditional_expression ::= (*) logical_or_expression , {RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on constant_expression to state [77]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [61]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [173]: {
  [type_augments ::= pointer_list brackets_list (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [174]: {
  [pointer_list ::= pointer_list TIMES (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [175]: {
  [type_name ::= ENUM ID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [176]: {
  [bitfield_list ::= bitfield_value bitfield_list (*) , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
}

-------------------
lalr_state [177]: {
  [declaration_list ::= declaration_list declaration (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [178]: {
  [$START ::= declaration_list EOF (*) , {EOF }]
}

-------------------
lalr_state [179]: {
  [declaration ::= TYPEDEF type (*) name SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) ID , {SEMICOLON }]
}
transition on name to state [180]
transition on ID to state [18]

-------------------
lalr_state [180]: {
  [declaration ::= TYPEDEF type name (*) SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [181]

-------------------
lalr_state [181]: {
  [declaration ::= TYPEDEF type name SEMICOLON (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [182]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [declaration ::= VAR bitfield_list (*) type name initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on type to state [183]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [183]: {
  [declaration ::= VAR bitfield_list type (*) name initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) ID , {ASSIGN }]
}
transition on name to state [184]
transition on ID to state [18]

-------------------
lalr_state [184]: {
  [declaration ::= VAR bitfield_list type name (*) initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [initialization ::= (*) ASSIGN initializer , {SEMICOLON }]
}
transition on ASSIGN to state [186]
transition on initialization to state [185]

-------------------
lalr_state [185]: {
  [declaration ::= VAR bitfield_list type name initialization (*) SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [195]

-------------------
lalr_state [186]: {
  [unary_expression ::= (*) NOT cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initialization ::= ASSIGN (*) initializer , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {SEMICOLON }]
  [Var ::= (*) ID , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on initializer to state [189]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on LBRACE to state [188]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [187]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [187]: {
  [initializer ::= assignment_expression (*) , {COMMA SEMICOLON RBRACE }]
}

-------------------
lalr_state [188]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= LBRACE (*) initializer_list RBRACE , {COMMA SEMICOLON RBRACE }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {COMMA RBRACE }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer_list ::= (*) initializer , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer_list ::= (*) initializer_list COMMA initializer , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on initializer to state [191]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on initializer_list to state [190]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on LBRACE to state [188]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [187]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [189]: {
  [initialization ::= ASSIGN initializer (*) , {SEMICOLON }]
}

-------------------
lalr_state [190]: {
  [initializer ::= LBRACE initializer_list (*) RBRACE , {COMMA SEMICOLON RBRACE }]
  [initializer_list ::= initializer_list (*) COMMA initializer , {COMMA RBRACE }]
}
transition on RBRACE to state [193]
transition on COMMA to state [192]

-------------------
lalr_state [191]: {
  [initializer_list ::= initializer (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [192]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {COMMA RBRACE }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [initializer_list ::= initializer_list COMMA (*) initializer , {COMMA RBRACE }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on initializer to state [194]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on LBRACE to state [188]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [187]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [193]: {
  [initializer ::= LBRACE initializer_list RBRACE (*) , {COMMA SEMICOLON RBRACE }]
}

-------------------
lalr_state [194]: {
  [initializer_list ::= initializer_list COMMA initializer (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [195]: {
  [declaration ::= VAR bitfield_list type name initialization SEMICOLON (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [196]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [declaration ::= FUN bitfield_list (*) type name type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [declaration ::= FUN bitfield_list (*) type name parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on type to state [197]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [197]: {
  [declaration ::= FUN bitfield_list type (*) name parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) ID , {LPAREN }]
  [declaration ::= FUN bitfield_list type (*) name type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on name to state [198]
transition on ID to state [18]

-------------------
lalr_state [198]: {
  [type_parameters ::= (*) LPAREN parameter_type_list RPAREN , {SEMICOLON }]
  [declaration ::= FUN bitfield_list type name (*) parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [parameters ::= (*) LPAREN RPAREN , {LBRACE }]
  [type_parameters ::= (*) LPAREN RPAREN , {SEMICOLON }]
  [parameters ::= (*) LPAREN parameter_list COMMA ELIPSES RPAREN , {LBRACE }]
  [type_parameters ::= (*) LPAREN parameter_type_list COMMA ELIPSES RPAREN , {SEMICOLON }]
  [declaration ::= FUN bitfield_list type name (*) type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [parameters ::= (*) LPAREN parameter_list RPAREN , {LBRACE }]
}
transition on LPAREN to state [201]
transition on parameters to state [200]
transition on type_parameters to state [199]

-------------------
lalr_state [199]: {
  [declaration ::= FUN bitfield_list type name type_parameters (*) SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [297]

-------------------
lalr_state [200]: {
  [declaration ::= FUN bitfield_list type name parameters (*) compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on compound_statement to state [219]
transition on LBRACE to state [218]

-------------------
lalr_state [201]: {
  [parameters ::= LPAREN (*) RPAREN , {LBRACE }]
  [type ::= (*) type_name , {ID COMMA RPAREN }]
  [type_name ::= (*) SHORT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) ENUM ID , {ID COMMA RPAREN LBRACK TIMES }]
  [parameters ::= LPAREN (*) parameter_list RPAREN , {LBRACE }]
  [parameter_type_list ::= (*) type , {COMMA RPAREN }]
  [type_name ::= (*) VOID , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN (*) parameter_type_list COMMA ELIPSES RPAREN , {SEMICOLON }]
  [parameter_list ::= (*) type name , {COMMA RPAREN }]
  [type_name ::= (*) INT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) ID , {ID COMMA RPAREN LBRACK TIMES }]
  [parameters ::= LPAREN (*) parameter_list COMMA ELIPSES RPAREN , {LBRACE }]
  [parameter_type_list ::= (*) parameter_type_list COMMA type , {COMMA RPAREN }]
  [type ::= (*) type_name type_augments , {ID COMMA RPAREN }]
  [type_name ::= (*) CHAR , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) DOUBLE , {ID COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN (*) RPAREN , {SEMICOLON }]
  [parameter_list ::= (*) parameter_list COMMA type name , {COMMA RPAREN }]
  [type_name ::= (*) LONG , {ID COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN (*) parameter_type_list RPAREN , {SEMICOLON }]
}
transition on SHORT to state [31]
transition on parameter_list to state [205]
transition on FLOAT to state [32]
transition on CHAR to state [33]
transition on parameter_type_list to state [204]
transition on RPAREN to state [203]
transition on type to state [202]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [202]: {
  [parameter_type_list ::= type (*) , {COMMA RPAREN }]
  [name ::= (*) ID , {COMMA RPAREN }]
  [parameter_list ::= type (*) name , {COMMA RPAREN }]
}
transition on name to state [217]
transition on ID to state [18]

-------------------
lalr_state [203]: {
  [parameters ::= LPAREN RPAREN (*) , {LBRACE }]
  [type_parameters ::= LPAREN RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [204]: {
  [type_parameters ::= LPAREN parameter_type_list (*) COMMA ELIPSES RPAREN , {SEMICOLON }]
  [parameter_type_list ::= parameter_type_list (*) COMMA type , {COMMA RPAREN }]
  [type_parameters ::= LPAREN parameter_type_list (*) RPAREN , {SEMICOLON }]
}
transition on RPAREN to state [213]
transition on COMMA to state [212]

-------------------
lalr_state [205]: {
  [parameter_list ::= parameter_list (*) COMMA type name , {COMMA RPAREN }]
  [parameters ::= LPAREN parameter_list (*) COMMA ELIPSES RPAREN , {LBRACE }]
  [parameters ::= LPAREN parameter_list (*) RPAREN , {LBRACE }]
}
transition on RPAREN to state [207]
transition on COMMA to state [206]

-------------------
lalr_state [206]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [parameter_list ::= parameter_list COMMA (*) type name , {COMMA RPAREN }]
  [parameters ::= LPAREN parameter_list COMMA (*) ELIPSES RPAREN , {LBRACE }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on ELIPSES to state [209]
transition on type to state [208]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [207]: {
  [parameters ::= LPAREN parameter_list RPAREN (*) , {LBRACE }]
}

-------------------
lalr_state [208]: {
  [parameter_list ::= parameter_list COMMA type (*) name , {COMMA RPAREN }]
  [name ::= (*) ID , {COMMA RPAREN }]
}
transition on name to state [211]
transition on ID to state [18]

-------------------
lalr_state [209]: {
  [parameters ::= LPAREN parameter_list COMMA ELIPSES (*) RPAREN , {LBRACE }]
}
transition on RPAREN to state [210]

-------------------
lalr_state [210]: {
  [parameters ::= LPAREN parameter_list COMMA ELIPSES RPAREN (*) , {LBRACE }]
}

-------------------
lalr_state [211]: {
  [parameter_list ::= parameter_list COMMA type name (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [212]: {
  [type_name ::= (*) ENUM ID , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) LONG , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) CHAR , {COMMA RPAREN LBRACK TIMES }]
  [type ::= (*) type_name , {COMMA RPAREN }]
  [type_name ::= (*) DOUBLE , {COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN parameter_type_list COMMA (*) ELIPSES RPAREN , {SEMICOLON }]
  [type_name ::= (*) INT , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) VOID , {COMMA RPAREN LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {COMMA RPAREN }]
  [parameter_type_list ::= parameter_type_list COMMA (*) type , {COMMA RPAREN }]
  [type_name ::= (*) ID , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) SHORT , {COMMA RPAREN LBRACK TIMES }]
}
transition on CHAR to state [33]
transition on FLOAT to state [32]
transition on SHORT to state [31]
transition on ELIPSES to state [215]
transition on type to state [214]
transition on ID to state [29]
transition on DOUBLE to state [28]
transition on VOID to state [26]
transition on LONG to state [25]
transition on type_name to state [24]
transition on INT to state [23]
transition on ENUM to state [22]

-------------------
lalr_state [213]: {
  [type_parameters ::= LPAREN parameter_type_list RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [214]: {
  [parameter_type_list ::= parameter_type_list COMMA type (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [215]: {
  [type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES (*) RPAREN , {SEMICOLON }]
}
transition on RPAREN to state [216]

-------------------
lalr_state [216]: {
  [type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [217]: {
  [parameter_list ::= type name (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [218]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [declaration_list ::= (*) declaration_list declaration , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration_list ::= (*) declaration , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) declaration_list statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) TYPEDEF type name SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement_list statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on statement_list to state [240]
transition on DO to state [239]
transition on VAR to state [6]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on declaration to state [3]
transition on VOLATILE to state [9]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [236]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on ENUM to state [1]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on AUTO to state [13]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [230]
transition on expression to state [229]
transition on ID to state [63]
transition on bitfield_value to state [11]
transition on IF to state [228]
transition on PLUS to state [52]
transition on TYPEDEF to state [7]
transition on EXTERN to state [8]
transition on cast_expression to state [54]
transition on FUN to state [4]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on STATIC to state [2]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on REGISTER to state [5]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on CONST to state [14]
transition on declaration_list to state [220]
transition on INCREMENT to state [72]
transition on bitfield_list to state [12]

-------------------
lalr_state [219]: {
  [declaration ::= FUN bitfield_list type name parameters compound_statement (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [220]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [declaration_list ::= declaration_list (*) declaration , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= LBRACE declaration_list (*) statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE declaration_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) TYPEDEF type name SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement_list statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on statement_list to state [295]
transition on DO to state [239]
transition on VAR to state [6]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on declaration to state [177]
transition on VOLATILE to state [9]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [294]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on ENUM to state [1]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on AUTO to state [13]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [230]
transition on expression to state [229]
transition on ID to state [63]
transition on bitfield_value to state [11]
transition on IF to state [228]
transition on PLUS to state [52]
transition on TYPEDEF to state [7]
transition on EXTERN to state [8]
transition on cast_expression to state [54]
transition on FUN to state [4]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on STATIC to state [2]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on REGISTER to state [5]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on CONST to state [14]
transition on INCREMENT to state [72]
transition on bitfield_list to state [12]

-------------------
lalr_state [221]: {
  [statement ::= iteration_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [222]: {
  [statement ::= jump_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [223]: {
  [primary_expression ::= Var (*) , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [labeled_statement ::= Var (*) COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on COLON to state [292]

-------------------
lalr_state [224]: {
  [jump_statement ::= CONTINUE (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [291]

-------------------
lalr_state [225]: {
  [statement ::= compound_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [226]: {
  [iteration_statement ::= FOR (*) LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [266]

-------------------
lalr_state [227]: {
  [expression_statement ::= SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [228]: {
  [selection_statement ::= IF (*) LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= IF (*) LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [260]

-------------------
lalr_state [229]: {
  [expression_statement ::= expression (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
}
transition on SEMICOLON to state [259]
transition on COMMA to state [153]

-------------------
lalr_state [230]: {
  [statement_list ::= statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [231]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [jump_statement ::= RETURN (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= RETURN (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [257]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on SEMICOLON to state [256]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [232]: {
  [statement ::= selection_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [233]: {
  [jump_statement ::= BREAK (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [255]

-------------------
lalr_state [234]: {
  [jump_statement ::= GOTO (*) Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {SEMICOLON }]
}
transition on Var to state [253]
transition on ID to state [63]

-------------------
lalr_state [235]: {
  [iteration_statement ::= WHILE (*) LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [249]

-------------------
lalr_state [236]: {
  [compound_statement ::= LBRACE RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [237]: {
  [statement ::= expression_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [238]: {
  [statement ::= labeled_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [239]: {
  [statement ::= (*) jump_statement , {WHILE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {WHILE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {WHILE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {WHILE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {WHILE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {WHILE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {WHILE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {WHILE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {WHILE }]
  [statement ::= (*) labeled_statement , {WHILE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {WHILE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= DO (*) statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {WHILE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {WHILE }]
  [statement ::= (*) compound_statement , {WHILE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {WHILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {WHILE }]
  [statement ::= (*) expression_statement , {WHILE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {WHILE }]
  [statement ::= (*) selection_statement , {WHILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {WHILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {WHILE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [243]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [240]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= LBRACE statement_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [statement_list ::= statement_list (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [242]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [241]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [241]: {
  [statement_list ::= statement_list statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [242]: {
  [compound_statement ::= LBRACE statement_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [243]: {
  [iteration_statement ::= DO statement (*) WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on WHILE to state [244]

-------------------
lalr_state [244]: {
  [iteration_statement ::= DO statement WHILE (*) LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [245]

-------------------
lalr_state [245]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= DO statement WHILE LPAREN (*) expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [246]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [246]: {
  [iteration_statement ::= DO statement WHILE LPAREN expression (*) RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [247]
transition on COMMA to state [153]

-------------------
lalr_state [247]: {
  [iteration_statement ::= DO statement WHILE LPAREN expression RPAREN (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [248]

-------------------
lalr_state [248]: {
  [iteration_statement ::= DO statement WHILE LPAREN expression RPAREN SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [249]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= WHILE LPAREN (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [250]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [250]: {
  [iteration_statement ::= WHILE LPAREN expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [251]
transition on COMMA to state [153]

-------------------
lalr_state [251]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= WHILE LPAREN expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [252]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [252]: {
  [iteration_statement ::= WHILE LPAREN expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [253]: {
  [jump_statement ::= GOTO Var (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [254]

-------------------
lalr_state [254]: {
  [jump_statement ::= GOTO Var SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [255]: {
  [jump_statement ::= BREAK SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [256]: {
  [jump_statement ::= RETURN SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [257]: {
  [jump_statement ::= RETURN expression (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
}
transition on SEMICOLON to state [258]
transition on COMMA to state [153]

-------------------
lalr_state [258]: {
  [jump_statement ::= RETURN expression SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [259]: {
  [expression_statement ::= expression SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [260]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN (*) expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [261]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [261]: {
  [selection_statement ::= IF LPAREN expression (*) RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= IF LPAREN expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [262]
transition on COMMA to state [153]

-------------------
lalr_state [262]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN expression RPAREN (*) statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [263]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [263]: {
  [selection_statement ::= IF LPAREN expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= IF LPAREN expression RPAREN statement (*) ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on ELSE to state [264]

-------------------
lalr_state [264]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [selection_statement ::= IF LPAREN expression RPAREN statement ELSE (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [265]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [265]: {
  [selection_statement ::= IF LPAREN expression RPAREN statement ELSE statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [266]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [268]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on SEMICOLON to state [267]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [267]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON (*) expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN SEMICOLON (*) SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN SEMICOLON (*) expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [282]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on SEMICOLON to state [281]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [268]: {
  [iteration_statement ::= FOR LPAREN expression (*) SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN expression (*) SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN expression (*) SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
}
transition on SEMICOLON to state [269]
transition on COMMA to state [153]

-------------------
lalr_state [269]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON (*) SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON (*) expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON (*) expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [271]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on SEMICOLON to state [270]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [270]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [278]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [271]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression (*) SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression (*) SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
}
transition on SEMICOLON to state [272]
transition on COMMA to state [153]

-------------------
lalr_state [272]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [274]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on assignment_expression to state [151]
transition on RPAREN to state [273]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [273]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on RETURN to state [231]
transition on unary_expression to state [122]
transition on statement to state [277]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [274]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [275]
transition on COMMA to state [153]

-------------------
lalr_state [275]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [276]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [276]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [277]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [278]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [279]
transition on COMMA to state [153]

-------------------
lalr_state [279]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [280]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [280]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [281]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on RPAREN to state [289]

-------------------
lalr_state [282]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON expression (*) SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression (*) SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
}
transition on SEMICOLON to state [283]
transition on COMMA to state [153]

-------------------
lalr_state [283]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [285]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [63]
transition on shift_expression to state [62]
transition on conditional_expression to state [123]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [122]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on RPAREN to state [284]
transition on assignment_expression to state [151]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [284]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on RETURN to state [231]
transition on unary_expression to state [122]
transition on statement to state [288]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [285]: {
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on RPAREN to state [286]
transition on COMMA to state [153]

-------------------
lalr_state [286]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [287]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [287]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [288]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [289]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on RETURN to state [231]
transition on unary_expression to state [122]
transition on statement to state [290]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [290]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [291]: {
  [jump_statement ::= CONTINUE SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [292]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= Var COLON (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [293]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [293]: {
  [labeled_statement ::= Var COLON statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [294]: {
  [compound_statement ::= LBRACE declaration_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [295]: {
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= LBRACE declaration_list statement_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [statement_list ::= statement_list (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on DO to state [239]
transition on labeled_statement to state [238]
transition on relational_expression to state [69]
transition on expression_statement to state [237]
transition on DECIMAL_LITERAL to state [55]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [296]
transition on WHILE to state [235]
transition on GOTO to state [234]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [218]
transition on and_expression to state [59]
transition on shift_expression to state [62]
transition on logical_and_expression to state [71]
transition on postfix_expression to state [65]
transition on BREAK to state [233]
transition on conditional_expression to state [123]
transition on selection_statement to state [232]
transition on error to state [74]
transition on unary_expression to state [122]
transition on RETURN to state [231]
transition on statement to state [241]
transition on expression to state [229]
transition on ID to state [63]
transition on IF to state [228]
transition on PLUS to state [52]
transition on cast_expression to state [54]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [70]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [50]
transition on SEMICOLON to state [227]
transition on NOT to state [56]
transition on primary_expression to state [51]
transition on TILDE to state [64]
transition on DECREMENT to state [57]
transition on FOR to state [226]
transition on MINUS to state [73]
transition on compound_statement to state [225]
transition on CONTINUE to state [224]
transition on Var to state [223]
transition on LPAREN to state [60]
transition on jump_statement to state [222]
transition on iteration_statement to state [221]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [296]: {
  [compound_statement ::= LBRACE declaration_list statement_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [297]: {
  [declaration ::= FUN bitfield_list type name type_parameters SEMICOLON (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [298]: {
  [declaration ::= ENUM ID (*) LBRACE enumerator_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on LBRACE to state [299]

-------------------
lalr_state [299]: {
  [enumerator ::= (*) ID , {COMMA RBRACE }]
  [enumerator_list ::= (*) enumerator_list COMMA enumerator , {COMMA RBRACE }]
  [declaration ::= ENUM ID LBRACE (*) enumerator_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [enumerator ::= (*) ID ASSIGN constant_expression , {COMMA RBRACE }]
  [enumerator_list ::= (*) enumerator , {COMMA RBRACE }]
}
transition on enumerator to state [302]
transition on enumerator_list to state [301]
transition on ID to state [300]

-------------------
lalr_state [300]: {
  [enumerator ::= ID (*) , {COMMA RBRACE }]
  [enumerator ::= ID (*) ASSIGN constant_expression , {COMMA RBRACE }]
}
transition on ASSIGN to state [306]

-------------------
lalr_state [301]: {
  [enumerator_list ::= enumerator_list (*) COMMA enumerator , {COMMA RBRACE }]
  [declaration ::= ENUM ID LBRACE enumerator_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on RBRACE to state [304]
transition on COMMA to state [303]

-------------------
lalr_state [302]: {
  [enumerator_list ::= enumerator (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [303]: {
  [enumerator ::= (*) ID , {COMMA RBRACE }]
  [enumerator_list ::= enumerator_list COMMA (*) enumerator , {COMMA RBRACE }]
  [enumerator ::= (*) ID ASSIGN constant_expression , {COMMA RBRACE }]
}
transition on enumerator to state [305]
transition on ID to state [300]

-------------------
lalr_state [304]: {
  [declaration ::= ENUM ID LBRACE enumerator_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [305]: {
  [enumerator_list ::= enumerator_list COMMA enumerator (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [306]: {
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [constant_expression ::= (*) conditional_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [enumerator ::= ID ASSIGN (*) constant_expression , {COMMA RBRACE }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on constant_expression to state [307]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [71]
transition on equality_expression to state [70]
transition on relational_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [62]
transition on ID to state [63]
transition on conditional_expression to state [61]
transition on LPAREN to state [60]
transition on and_expression to state [59]
transition on unary_expression to state [58]
transition on DECREMENT to state [57]
transition on NOT to state [56]
transition on DECIMAL_LITERAL to state [55]
transition on cast_expression to state [54]
transition on Var to state [53]
transition on PLUS to state [52]
transition on primary_expression to state [51]
transition on SIZEOF to state [50]

-------------------
lalr_state [307]: {
  [enumerator ::= ID ASSIGN constant_expression (*) , {COMMA RBRACE }]
}

-------------------
Closing files...
------- CUP v0.10g Parser Generation Summary -------
  0 errors and 3 warnings
  80 terminals, 55 non terminals, and 164 productions declared, 
  producing 308 unique parse states.
  2 terminals declared but not used.
  0 non terminals declared but not used.
  0 productions never reduced.
  1 conflict detected (3 expected).
  Code written to "Grm.java", and "sym.java".
---------------------------------------------------- (v0.10g)
