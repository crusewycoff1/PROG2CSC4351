/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("package",    new Integer(sym.PACKAGE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("package",    new Integer(sym.PACKAGE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("import",     new Integer(sym.IMPORT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("import",     new Integer(sym.IMPORT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("code",       new Integer(sym.CODE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("code",       new Integer(sym.CODE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("action",     new Integer(sym.ACTION));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("action",     new Integer(sym.ACTION));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("parser",     new Integer(sym.PARSER));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("parser",     new Integer(sym.PARSER));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("non",        new Integer(sym.NON));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("non",        new Integer(sym.NON));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("init",       new Integer(sym.INIT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("init",       new Integer(sym.INIT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("scan",       new Integer(sym.SCAN));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("scan",       new Integer(sym.SCAN));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("with",       new Integer(sym.WITH));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("with",       new Integer(sym.WITH));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("start",      new Integer(sym.START));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("start",      new Integer(sym.START));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("left",       new Integer(sym.LEFT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("left",       new Integer(sym.LEFT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("right",      new Integer(sym.RIGHT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("right",      new Integer(sym.RIGHT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:278: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      result = (Integer)char_symbols.get(new Integer((char)ch));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:368: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	  result.append(new Character((char)next_char));
	                ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:533: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	    new Character((char)next_char) + "'(" + next_char + 
	    ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:538: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(new Symbol(0, start_state()));
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:559: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_token);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:588: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:728: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(new Symbol(0, start_state()));
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:751: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_token);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:786: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:955: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(error_token);
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:1153: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_err_token());
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:1199: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:788: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
	      non_terms.put(non_term_id, this_nt);
	                   ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:791: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
	      symbols.put(non_term_id, new symbol_part(this_nt));
	                 ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:820: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
	      symbols.put(term_id, 
	                 ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:1728: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	  emit.import_list.push(multipart_name);
	                       ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:1818: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          symbols.put("error", new symbol_part(terminal.error));
                     ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:1821: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          non_terms.put("$START", non_terminal.START_nt);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:93: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      vstack.push(new Integer(stack_sym.parse_state));
                  ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:93: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      vstack.push(new Integer(stack_sym.parse_state));
                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      vstack.push(new Integer(state_num));
                  ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:140: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      vstack.push(new Integer(state_num));
                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
75 warnings
Opening files...
Parsing specification from standard input...
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:538: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(new Symbol(0, start_state()));
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:559: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_token);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:588: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:728: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(new Symbol(0, start_state()));
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:751: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_token);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:786: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:955: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(error_token);
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:1153: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_err_token());
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:1199: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:788: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
	      non_terms.put(non_term_id, this_nt);
	                   ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:791: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
	      symbols.put(non_term_id, new symbol_part(this_nt));
	                 ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:820: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
	      symbols.put(term_id, 
	                 ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:1728: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	  emit.import_list.push(multipart_name);
	                       ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:1818: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          symbols.put("error", new symbol_part(terminal.error));
                     ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/parser.java:1821: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          non_terms.put("$START", non_terminal.START_nt);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:93: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      vstack.push(new Integer(stack_sym.parse_state));
                  ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:93: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      vstack.push(new Integer(stack_sym.parse_state));
                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      vstack.push(new Integer(state_num));
                  ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:140: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      vstack.push(new Integer(state_num));
                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("package",    new Integer(sym.PACKAGE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("package",    new Integer(sym.PACKAGE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("import",     new Integer(sym.IMPORT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("import",     new Integer(sym.IMPORT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("code",       new Integer(sym.CODE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("code",       new Integer(sym.CODE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("action",     new Integer(sym.ACTION));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("action",     new Integer(sym.ACTION));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("parser",     new Integer(sym.PARSER));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("parser",     new Integer(sym.PARSER));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("non",        new Integer(sym.NON));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("non",        new Integer(sym.NON));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("init",       new Integer(sym.INIT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("init",       new Integer(sym.INIT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("scan",       new Integer(sym.SCAN));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("scan",       new Integer(sym.SCAN));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("with",       new Integer(sym.WITH));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("with",       new Integer(sym.WITH));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("start",      new Integer(sym.START));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("start",      new Integer(sym.START));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("left",       new Integer(sym.LEFT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("left",       new Integer(sym.LEFT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("right",      new Integer(sym.RIGHT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("right",      new Integer(sym.RIGHT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:278: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      result = (Integer)char_symbols.get(new Integer((char)ch));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:368: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	  result.append(new Character((char)next_char));
	                ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:533: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	    new Character((char)next_char) + "'(" + next_char + 
	    ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:78: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
     _all.put(_items,this);
             ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:307: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      work_stack.push(start_state);
                     ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:310: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_kernels.put(kernel, start_state);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:372: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
		  work_stack.push(new_st);
		                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:375: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
		  _all_kernels.put(kernel, new_st);
		                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:397: warning: [unchecked] unchecked call to setElementAt(E,int) as a member of the raw type Vector
			    fix_itm.propagate_items().setElementAt(existing ,l);
			                                          ^
  where E is a type-variable:
    E extends Object declared in class Vector
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          _all.put(itm,itm);
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:347: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
	  hashcode_cache = new Integer(result);
	                   ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item.java:103: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      _propagate_items.push(prop_to);
                           ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/symbol_set.java:109: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      previous = _all.put(sym.name(),sym);
                         ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
85 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:538: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(new Symbol(0, start_state()));
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:559: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_token);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:588: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:728: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(new Symbol(0, start_state()));
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:751: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_token);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:786: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:955: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      stack.push(error_token);
                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:1153: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(cur_err_token());
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/lr_parser.java:1199: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
	      stack.push(lhs_sym);
	                ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:93: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      vstack.push(new Integer(stack_sym.parse_state));
                  ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:93: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      vstack.push(new Integer(stack_sym.parse_state));
                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      vstack.push(new Integer(state_num));
                  ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/runtime/virtual_parse_stack.java:140: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      vstack.push(new Integer(state_num));
                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
13 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:31: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      Object conflict = _all.put(nm,this);
                                ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:43: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all_by_index.put(new Integer(_index), this);
                        ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:43: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_by_index.put(new Integer(_index), this);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:85: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      Integer the_indx = new Integer(indx);
                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:248: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _productions.put(prod,prod);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
5 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:32: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      Object conflict = _all.put(nm,this);
                                ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:48: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all_by_index.put(new Integer(_index), this);
                        ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:48: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_by_index.put(new Integer(_index), this);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:108: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      Integer the_indx = new Integer(indx);
                         ^
4 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("package",    new Integer(sym.PACKAGE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("package",    new Integer(sym.PACKAGE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("import",     new Integer(sym.IMPORT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("import",     new Integer(sym.IMPORT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("code",       new Integer(sym.CODE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("code",       new Integer(sym.CODE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("action",     new Integer(sym.ACTION));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("action",     new Integer(sym.ACTION));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("parser",     new Integer(sym.PARSER));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("parser",     new Integer(sym.PARSER));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("non",        new Integer(sym.NON));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("non",        new Integer(sym.NON));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("init",       new Integer(sym.INIT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("init",       new Integer(sym.INIT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("scan",       new Integer(sym.SCAN));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("scan",       new Integer(sym.SCAN));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("with",       new Integer(sym.WITH));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("with",       new Integer(sym.WITH));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("start",      new Integer(sym.START));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("start",      new Integer(sym.START));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("left",       new Integer(sym.LEFT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("left",       new Integer(sym.LEFT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("right",      new Integer(sym.RIGHT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("right",      new Integer(sym.RIGHT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:278: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      result = (Integer)char_symbols.get(new Integer((char)ch));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:368: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	  result.append(new Character((char)next_char));
	                ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:533: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	    new Character((char)next_char) + "'(" + next_char + 
	    ^
56 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:157: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all.put(new Integer(_index),this);
               ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:157: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all.put(new Integer(_index),this);
              ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:230: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
    return (production) _all.get(new Integer(indx));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:78: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
     _all.put(_items,this);
             ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:307: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      work_stack.push(start_state);
                     ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:310: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_kernels.put(kernel, start_state);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:372: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
		  work_stack.push(new_st);
		                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:375: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
		  _all_kernels.put(kernel, new_st);
		                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:397: warning: [unchecked] unchecked call to setElementAt(E,int) as a member of the raw type Vector
			    fix_itm.propagate_items().setElementAt(existing ,l);
			                                          ^
  where E is a type-variable:
    E extends Object declared in class Vector
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          _all.put(itm,itm);
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:347: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
	  hashcode_cache = new Integer(result);
	                   ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item.java:103: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      _propagate_items.push(prop_to);
                           ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("package",    new Integer(sym.PACKAGE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("package",    new Integer(sym.PACKAGE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("import",     new Integer(sym.IMPORT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("import",     new Integer(sym.IMPORT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("code",       new Integer(sym.CODE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("code",       new Integer(sym.CODE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("action",     new Integer(sym.ACTION));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("action",     new Integer(sym.ACTION));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("parser",     new Integer(sym.PARSER));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("parser",     new Integer(sym.PARSER));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("non",        new Integer(sym.NON));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("non",        new Integer(sym.NON));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("init",       new Integer(sym.INIT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("init",       new Integer(sym.INIT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("scan",       new Integer(sym.SCAN));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("scan",       new Integer(sym.SCAN));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("with",       new Integer(sym.WITH));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("with",       new Integer(sym.WITH));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("start",      new Integer(sym.START));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("start",      new Integer(sym.START));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("left",       new Integer(sym.LEFT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("left",       new Integer(sym.LEFT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("right",      new Integer(sym.RIGHT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("right",      new Integer(sym.RIGHT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:278: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      result = (Integer)char_symbols.get(new Integer((char)ch));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:368: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	  result.append(new Character((char)next_char));
	                ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:533: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	    new Character((char)next_char) + "'(" + next_char + 
	    ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/symbol_set.java:109: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      previous = _all.put(sym.name(),sym);
                         ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
69 warnings
Checking specification...
Warning: Terminal "STRING_LITERAL" was declared but never used
Warning: Terminal "CHAR_LITERAL" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:78: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
     _all.put(_items,this);
             ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:307: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      work_stack.push(start_state);
                     ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:310: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_kernels.put(kernel, start_state);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:372: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
		  work_stack.push(new_st);
		                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:375: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
		  _all_kernels.put(kernel, new_st);
		                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:397: warning: [unchecked] unchecked call to setElementAt(E,int) as a member of the raw type Vector
			    fix_itm.propagate_items().setElementAt(existing ,l);
			                                          ^
  where E is a type-variable:
    E extends Object declared in class Vector
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/symbol_set.java:109: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      previous = _all.put(sym.name(),sym);
                         ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("package",    new Integer(sym.PACKAGE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("package",    new Integer(sym.PACKAGE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("import",     new Integer(sym.IMPORT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("import",     new Integer(sym.IMPORT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("code",       new Integer(sym.CODE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("code",       new Integer(sym.CODE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("action",     new Integer(sym.ACTION));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("action",     new Integer(sym.ACTION));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("parser",     new Integer(sym.PARSER));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("parser",     new Integer(sym.PARSER));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("non",        new Integer(sym.NON));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("non",        new Integer(sym.NON));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("init",       new Integer(sym.INIT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("init",       new Integer(sym.INIT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("scan",       new Integer(sym.SCAN));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("scan",       new Integer(sym.SCAN));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("with",       new Integer(sym.WITH));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("with",       new Integer(sym.WITH));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("start",      new Integer(sym.START));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("start",      new Integer(sym.START));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("left",       new Integer(sym.LEFT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("left",       new Integer(sym.LEFT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("right",      new Integer(sym.RIGHT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("right",      new Integer(sym.RIGHT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:278: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      result = (Integer)char_symbols.get(new Integer((char)ch));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:368: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	  result.append(new Character((char)next_char));
	                ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:533: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	    new Character((char)next_char) + "'(" + next_char + 
	    ^
63 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          _all.put(itm,itm);
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:347: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
	  hashcode_cache = new Integer(result);
	                   ^
2 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item.java:103: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      _propagate_items.push(prop_to);
                           ^
  where E is a type-variable:
    E extends Object declared in class Stack
1 warning
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/symbol_set.java:109: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      previous = _all.put(sym.name(),sym);
                         ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
1 warning
  Filling in tables...
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:78: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
     _all.put(_items,this);
             ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:307: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      work_stack.push(start_state);
                     ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:310: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_kernels.put(kernel, start_state);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:372: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
		  work_stack.push(new_st);
		                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:375: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
		  _all_kernels.put(kernel, new_st);
		                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:397: warning: [unchecked] unchecked call to setElementAt(E,int) as a member of the raw type Vector
			    fix_itm.propagate_items().setElementAt(existing ,l);
			                                          ^
  where E is a type-variable:
    E extends Object declared in class Vector
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          _all.put(itm,itm);
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:347: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
	  hashcode_cache = new Integer(result);
	                   ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:157: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all.put(new Integer(_index),this);
               ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:157: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all.put(new Integer(_index),this);
              ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:230: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
    return (production) _all.get(new Integer(indx));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item.java:103: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      _propagate_items.push(prop_to);
                           ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:31: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      Object conflict = _all.put(nm,this);
                                ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:43: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all_by_index.put(new Integer(_index), this);
                        ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:43: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_by_index.put(new Integer(_index), this);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:85: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      Integer the_indx = new Integer(indx);
                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:248: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _productions.put(prod,prod);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:32: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      Object conflict = _all.put(nm,this);
                                ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:48: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all_by_index.put(new Integer(_index), this);
                        ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:48: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_by_index.put(new Integer(_index), this);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:108: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      Integer the_indx = new Integer(indx);
                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("package",    new Integer(sym.PACKAGE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("package",    new Integer(sym.PACKAGE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("import",     new Integer(sym.IMPORT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("import",     new Integer(sym.IMPORT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("code",       new Integer(sym.CODE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("code",       new Integer(sym.CODE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("action",     new Integer(sym.ACTION));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("action",     new Integer(sym.ACTION));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("parser",     new Integer(sym.PARSER));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("parser",     new Integer(sym.PARSER));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("non",        new Integer(sym.NON));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("non",        new Integer(sym.NON));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("init",       new Integer(sym.INIT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("init",       new Integer(sym.INIT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("scan",       new Integer(sym.SCAN));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("scan",       new Integer(sym.SCAN));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("with",       new Integer(sym.WITH));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("with",       new Integer(sym.WITH));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("start",      new Integer(sym.START));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("start",      new Integer(sym.START));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("left",       new Integer(sym.LEFT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("left",       new Integer(sym.LEFT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("right",      new Integer(sym.RIGHT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("right",      new Integer(sym.RIGHT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:278: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      result = (Integer)char_symbols.get(new Integer((char)ch));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:368: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	  result.append(new Character((char)next_char));
	                ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:533: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	    new Character((char)next_char) + "'(" + next_char + 
	    ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/symbol_set.java:109: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      previous = _all.put(sym.name(),sym);
                         ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
78 warnings
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:32: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      Object conflict = _all.put(nm,this);
                                ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:48: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all_by_index.put(new Integer(_index), this);
                        ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:48: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_by_index.put(new Integer(_index), this);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/terminal.java:108: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      Integer the_indx = new Integer(indx);
                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:157: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all.put(new Integer(_index),this);
               ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:157: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all.put(new Integer(_index),this);
              ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/production.java:230: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
    return (production) _all.get(new Integer(indx));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:31: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      Object conflict = _all.put(nm,this);
                                ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:43: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      _all_by_index.put(new Integer(_index), this);
                        ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:43: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_by_index.put(new Integer(_index), this);
                       ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:85: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      Integer the_indx = new Integer(indx);
                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/non_terminal.java:248: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _productions.put(prod,prod);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:78: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
     _all.put(_items,this);
             ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:307: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      work_stack.push(start_state);
                     ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:310: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      _all_kernels.put(kernel, start_state);
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:372: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
		  work_stack.push(new_st);
		                 ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:375: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
		  _all_kernels.put(kernel, new_st);
		                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_state.java:397: warning: [unchecked] unchecked call to setElementAt(E,int) as a member of the raw type Vector
			    fix_itm.propagate_items().setElementAt(existing ,l);
			                                          ^
  where E is a type-variable:
    E extends Object declared in class Vector
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
          _all.put(itm,itm);
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item_set.java:347: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
	  hashcode_cache = new Integer(result);
	                   ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lalr_item.java:103: warning: [unchecked] unchecked call to push(E) as a member of the raw type Stack
      _propagate_items.push(prop_to);
                           ^
  where E is a type-variable:
    E extends Object declared in class Stack
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("package",    new Integer(sym.PACKAGE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:127: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("package",    new Integer(sym.PACKAGE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("import",     new Integer(sym.IMPORT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:128: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("import",     new Integer(sym.IMPORT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("code",       new Integer(sym.CODE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:129: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("code",       new Integer(sym.CODE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("action",     new Integer(sym.ACTION));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:130: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("action",     new Integer(sym.ACTION));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("parser",     new Integer(sym.PARSER));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:131: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("parser",     new Integer(sym.PARSER));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:132: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("terminal",   new Integer(sym.TERMINAL));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("non",        new Integer(sym.NON));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:133: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("non",        new Integer(sym.NON));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:134: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonterminal",new Integer(sym.NONTERMINAL));// [CSA]
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("init",       new Integer(sym.INIT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:135: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("init",       new Integer(sym.INIT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("scan",       new Integer(sym.SCAN));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:136: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("scan",       new Integer(sym.SCAN));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("with",       new Integer(sym.WITH));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:137: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("with",       new Integer(sym.WITH));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("start",      new Integer(sym.START));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:138: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("start",      new Integer(sym.START));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:139: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("precedence", new Integer(sym.PRECEDENCE));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("left",       new Integer(sym.LEFT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:140: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("left",       new Integer(sym.LEFT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("right",      new Integer(sym.RIGHT));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:141: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("right",      new Integer(sym.RIGHT));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                                 ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:142: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      keywords.put("nonassoc",   new Integer(sym.NONASSOC));
                  ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:145: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(';'), new Integer(sym.SEMI));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:146: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(','), new Integer(sym.COMMA));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:147: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('*'), new Integer(sym.STAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:148: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('.'), new Integer(sym.DOT));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:149: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('|'), new Integer(sym.BAR));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:150: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer('['), new Integer(sym.LBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                       ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:151: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      char_symbols.put(new Integer(']'), new Integer(sym.RBRACK));
                      ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:278: warning: [removal] Integer(int) in Integer has been deprecated and marked for removal
      result = (Integer)char_symbols.get(new Integer((char)ch));
                                         ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:368: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	  result.append(new Character((char)next_char));
	                ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/lexer.java:533: warning: [removal] Character(char) in Character has been deprecated and marked for removal
	    new Character((char)next_char) + "'(" + next_char + 
	    ^
/Users/asherbordelon/IdeaProjects/PROG2CSC4351/Parse/../lib/java_cup/symbol_set.java:109: warning: [unchecked] unchecked call to put(K,V) as a member of the raw type Hashtable
      previous = _all.put(sym.name(),sym);
                         ^
  where K,V are type-variables:
    K extends Object declared in class Hashtable
    V extends Object declared in class Hashtable
78 warnings
*** Shift/Reduce conflict found in state #262
  between selection_statement ::= IF LPAREN expression RPAREN statement (*) 
  and     selection_statement ::= IF LPAREN expression RPAREN statement (*) ELSE statement 
  under symbol ELSE
  Resolved in favor of shifting.

  Checking for non-reduced productions...
Writing parser...
===== Terminals =====
[0]EOF [1]error [2]ID [3]STRING_LITERAL [4]DECIMAL_LITERAL 
[5]CHAR_LITERAL [6]INT [7]COMMA [8]COLON [9]SEMICOLON 
[10]LPAREN [11]RPAREN [12]LBRACK [13]RBRACK [14]LBRACE 
[15]RBRACE [16]PLUS [17]MINUS [18]TIMES [19]DIVIDE 
[20]EQ [21]NEQ [22]LT [23]LE [24]GT 
[25]GE [26]AND [27]OR [28]ASSIGN [29]IF 
[30]ELSE [31]WHILE [32]FOR [33]DO [34]BREAK 
[35]FUN [36]VAR [37]VOLATILE [38]NOT [39]REGISTER 
[40]CONTINUE [41]TYPEDEF [42]STRUCT [43]STATIC [44]SIZEOF 
[45]RETURN [46]EXTERN [47]DOUBLE [48]UNION [49]SHORT 
[50]FLOAT [51]CONST [52]VOID [53]LONG [54]GOTO 
[55]ENUM [56]CHAR [57]AUTO [58]RSHIFTASSIGN [59]LSHIFTASSIGN 
[60]ELIPSES [61]BWISEORASSIGN [62]BWISEXORASSIGN [63]RSHIFT [64]LSHIFT 
[65]DIVASSIGN [66]ARROW [67]SUBASSIGN [68]DECREMENT [69]ADDASSIGN 
[70]INCREMENT [71]MULASSIGN [72]BWISEANDASSIGN [73]MODASSIGN [74]TILDE 
[75]BWISEOR [76]BWISEXOR [77]PERIOD [78]BITWISEAND [79]MODULUS 


===== Non terminals =====
[0]$START [1]primary_expression [2]assignment_expression [3]postfix_expression [4]cast_expression 
[5]unary_expression [6]multiplicative_expression [7]additive_expression [8]shift_expression [9]relational_expression 
[10]equality_expression [11]and_expression [12]exclusive_or_expression [13]inclusive_or_expression [14]logical_and_expression 
[15]logical_or_expression [16]expression [17]conditional_expression [18]constant_expression [19]initializer 
[20]initialization [21]enumerator [22]Var [23]name [24]statement 
[25]compound_statement [26]labeled_statement [27]expression_statement [28]selection_statement [29]iteration_statement 
[30]jump_statement [31]statement_list [32]declaration_list [33]type_name [34]type 
[35]parameters [36]parameter_list [37]type_parameters [38]parameter_type_list [39]struct_or_union_declarator 
[40]struct_declaration_list [41]declaration [42]enumerator_list [43]argument_expression_list [44]expression_array_type 
[45]bitfield_list [46]bitfield_value [47]empty_array_type_list [48]empty_array_type [49]expression_array_type_list 
[50]type_augments [51]brackets_list [52]pointer_list [53]struct_or_union [54]initializer_list 


===== Productions =====
[0] $START ::= declaration_list EOF 
[1] declaration_list ::= declaration_list declaration 
[2] declaration_list ::= declaration 
[3] declaration ::= VAR bitfield_list type name initialization SEMICOLON 
[4] declaration ::= FUN bitfield_list type name parameters compound_statement 
[5] declaration ::= FUN bitfield_list type name type_parameters SEMICOLON 
[6] declaration ::= TYPEDEF type name 
[7] declaration ::= bitfield_list struct_or_union name struct_or_union_declarator 
[8] declaration ::= ENUM ID LBRACE enumerator_list RBRACE 
[9] name ::= Var 
[10] bitfield_list ::= 
[11] bitfield_list ::= bitfield_value bitfield_list 
[12] bitfield_value ::= CONST 
[13] bitfield_value ::= VOLATILE 
[14] bitfield_value ::= EXTERN 
[15] bitfield_value ::= STATIC 
[16] bitfield_value ::= AUTO 
[17] bitfield_value ::= REGISTER 
[18] empty_array_type_list ::= empty_array_type 
[19] empty_array_type_list ::= empty_array_type_list empty_array_type 
[20] empty_array_type ::= LBRACK RBRACK 
[21] expression_array_type_list ::= expression_array_type 
[22] expression_array_type_list ::= expression_array_type_list expression_array_type 
[23] expression_array_type ::= LBRACK constant_expression RBRACK 
[24] type ::= type_name type_augments 
[25] type ::= type_name 
[26] type_augments ::= pointer_list 
[27] type_augments ::= brackets_list 
[28] type_augments ::= pointer_list brackets_list 
[29] brackets_list ::= empty_array_type_list 
[30] brackets_list ::= expression_array_type_list 
[31] pointer_list ::= TIMES 
[32] pointer_list ::= pointer_list TIMES 
[33] type_name ::= VOID 
[34] type_name ::= CHAR 
[35] type_name ::= SHORT 
[36] type_name ::= INT 
[37] type_name ::= LONG 
[38] type_name ::= FLOAT 
[39] type_name ::= DOUBLE 
[40] type_name ::= ENUM ID 
[41] type_name ::= ID 
[42] initialization ::= 
[43] initialization ::= ASSIGN initializer 
[44] struct_or_union_declarator ::= LBRACE struct_declaration_list RBRACE 
[45] enumerator_list ::= enumerator 
[46] enumerator_list ::= enumerator_list COMMA enumerator 
[47] enumerator ::= ID 
[48] enumerator ::= ID ASSIGN constant_expression 
[49] struct_declaration_list ::= type name SEMICOLON 
[50] struct_declaration_list ::= struct_declaration_list type name SEMICOLON 
[51] struct_or_union ::= STRUCT 
[52] struct_or_union ::= UNION 
[53] type_parameters ::= LPAREN parameter_type_list RPAREN 
[54] type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES RPAREN 
[55] type_parameters ::= LPAREN RPAREN 
[56] parameters ::= LPAREN parameter_list RPAREN 
[57] parameters ::= LPAREN parameter_list COMMA ELIPSES RPAREN 
[58] parameters ::= LPAREN RPAREN 
[59] parameter_list ::= type name 
[60] parameter_list ::= parameter_list COMMA type name 
[61] parameter_type_list ::= type 
[62] parameter_type_list ::= parameter_type_list COMMA type 
[63] initializer_list ::= initializer 
[64] initializer_list ::= initializer_list COMMA initializer 
[65] initializer ::= assignment_expression 
[66] initializer ::= LBRACE initializer_list RBRACE 
[67] primary_expression ::= error 
[68] primary_expression ::= Var 
[69] primary_expression ::= DECIMAL_LITERAL 
[70] primary_expression ::= LPAREN expression RPAREN 
[71] postfix_expression ::= primary_expression 
[72] postfix_expression ::= postfix_expression LBRACK expression RBRACK 
[73] postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN 
[74] postfix_expression ::= postfix_expression LPAREN RPAREN 
[75] postfix_expression ::= postfix_expression INCREMENT 
[76] postfix_expression ::= postfix_expression DECREMENT 
[77] postfix_expression ::= postfix_expression PERIOD Var 
[78] postfix_expression ::= postfix_expression ARROW Var 
[79] argument_expression_list ::= assignment_expression 
[80] argument_expression_list ::= argument_expression_list COMMA assignment_expression 
[81] unary_expression ::= postfix_expression 
[82] unary_expression ::= INCREMENT unary_expression 
[83] unary_expression ::= DECREMENT unary_expression 
[84] unary_expression ::= PLUS cast_expression 
[85] unary_expression ::= MINUS cast_expression 
[86] unary_expression ::= TILDE cast_expression 
[87] unary_expression ::= NOT cast_expression 
[88] unary_expression ::= SIZEOF LPAREN type_name RPAREN 
[89] cast_expression ::= unary_expression 
[90] multiplicative_expression ::= cast_expression 
[91] multiplicative_expression ::= multiplicative_expression TIMES cast_expression 
[92] multiplicative_expression ::= multiplicative_expression DIVIDE cast_expression 
[93] multiplicative_expression ::= multiplicative_expression MODULUS cast_expression 
[94] additive_expression ::= multiplicative_expression 
[95] additive_expression ::= additive_expression PLUS multiplicative_expression 
[96] additive_expression ::= additive_expression MINUS multiplicative_expression 
[97] shift_expression ::= additive_expression 
[98] shift_expression ::= shift_expression RSHIFT additive_expression 
[99] shift_expression ::= shift_expression LSHIFT additive_expression 
[100] relational_expression ::= shift_expression 
[101] relational_expression ::= relational_expression GE shift_expression 
[102] relational_expression ::= relational_expression GT shift_expression 
[103] relational_expression ::= relational_expression LE shift_expression 
[104] relational_expression ::= relational_expression LT shift_expression 
[105] equality_expression ::= relational_expression 
[106] equality_expression ::= equality_expression EQ relational_expression 
[107] equality_expression ::= equality_expression NEQ relational_expression 
[108] and_expression ::= equality_expression 
[109] and_expression ::= and_expression BITWISEAND equality_expression 
[110] exclusive_or_expression ::= and_expression 
[111] exclusive_or_expression ::= and_expression BWISEXOR equality_expression 
[112] inclusive_or_expression ::= exclusive_or_expression 
[113] inclusive_or_expression ::= inclusive_or_expression BWISEOR exclusive_or_expression 
[114] logical_and_expression ::= inclusive_or_expression 
[115] logical_and_expression ::= logical_and_expression AND inclusive_or_expression 
[116] logical_or_expression ::= logical_and_expression 
[117] logical_or_expression ::= logical_or_expression OR logical_and_expression 
[118] conditional_expression ::= logical_or_expression 
[119] constant_expression ::= conditional_expression 
[120] assignment_expression ::= conditional_expression 
[121] assignment_expression ::= unary_expression ASSIGN assignment_expression 
[122] assignment_expression ::= unary_expression ADDASSIGN assignment_expression 
[123] assignment_expression ::= unary_expression SUBASSIGN assignment_expression 
[124] assignment_expression ::= unary_expression DIVASSIGN assignment_expression 
[125] assignment_expression ::= unary_expression MULASSIGN assignment_expression 
[126] assignment_expression ::= unary_expression MODASSIGN assignment_expression 
[127] assignment_expression ::= unary_expression BWISEANDASSIGN assignment_expression 
[128] assignment_expression ::= unary_expression BWISEORASSIGN assignment_expression 
[129] assignment_expression ::= unary_expression BWISEXORASSIGN assignment_expression 
[130] assignment_expression ::= unary_expression LSHIFTASSIGN assignment_expression 
[131] assignment_expression ::= unary_expression RSHIFTASSIGN assignment_expression 
[132] expression ::= assignment_expression 
[133] expression ::= expression COMMA assignment_expression 
[134] Var ::= ID 
[135] statement ::= labeled_statement 
[136] statement ::= compound_statement 
[137] statement ::= expression_statement 
[138] statement ::= selection_statement 
[139] statement ::= iteration_statement 
[140] statement ::= jump_statement 
[141] labeled_statement ::= Var COLON statement 
[142] compound_statement ::= LBRACE declaration_list statement_list RBRACE 
[143] compound_statement ::= LBRACE statement_list RBRACE 
[144] compound_statement ::= LBRACE declaration_list RBRACE 
[145] compound_statement ::= LBRACE RBRACE 
[146] statement_list ::= statement 
[147] statement_list ::= statement_list statement 
[148] expression_statement ::= expression SEMICOLON 
[149] expression_statement ::= SEMICOLON 
[150] selection_statement ::= IF LPAREN expression RPAREN statement 
[151] selection_statement ::= IF LPAREN expression RPAREN statement ELSE statement 
[152] iteration_statement ::= WHILE LPAREN expression RPAREN statement 
[153] iteration_statement ::= DO statement WHILE LPAREN expression RPAREN SEMICOLON 
[154] iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement 
[155] iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement 
[156] iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement 
[157] iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON RPAREN statement 
[158] iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement 
[159] iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement 
[160] jump_statement ::= GOTO Var SEMICOLON 
[161] jump_statement ::= CONTINUE SEMICOLON 
[162] jump_statement ::= BREAK SEMICOLON 
[163] jump_statement ::= RETURN expression SEMICOLON 
[164] jump_statement ::= RETURN SEMICOLON 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration_list ::= (*) declaration , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration_list ::= (*) declaration_list declaration , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [declaration ::= (*) TYPEDEF type name , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [$START ::= (*) declaration_list EOF , {EOF }]
}
transition on CONST to state [14]
transition on AUTO to state [13]
transition on bitfield_list to state [12]
transition on bitfield_value to state [11]
transition on declaration_list to state [10]
transition on VOLATILE to state [9]
transition on EXTERN to state [8]
transition on TYPEDEF to state [7]
transition on VAR to state [6]
transition on REGISTER to state [5]
transition on FUN to state [4]
transition on declaration to state [3]
transition on STATIC to state [2]
transition on ENUM to state [1]

-------------------
lalr_state [1]: {
  [declaration ::= ENUM (*) ID LBRACE enumerator_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on ID to state [297]

-------------------
lalr_state [2]: {
  [bitfield_value ::= STATIC (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [3]: {
  [declaration_list ::= declaration (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [4]: {
  [bitfield_value ::= (*) REGISTER , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) EXTERN , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [declaration ::= FUN (*) bitfield_list type name type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [bitfield_value ::= (*) AUTO , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) VOLATILE , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [declaration ::= FUN (*) bitfield_list type name parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [bitfield_value ::= (*) STATIC , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) CONST , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}
transition on bitfield_value to state [11]
transition on EXTERN to state [8]
transition on AUTO to state [13]
transition on REGISTER to state [5]
transition on bitfield_list to state [195]
transition on STATIC to state [2]
transition on VOLATILE to state [9]
transition on CONST to state [14]

-------------------
lalr_state [5]: {
  [bitfield_value ::= REGISTER (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [6]: {
  [bitfield_value ::= (*) REGISTER , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) EXTERN , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) AUTO , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) VOLATILE , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) , {ID INT DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) STATIC , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) CONST , {ID INT VOLATILE REGISTER STATIC EXTERN DOUBLE SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [declaration ::= VAR (*) bitfield_list type name initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on bitfield_value to state [11]
transition on EXTERN to state [8]
transition on AUTO to state [13]
transition on REGISTER to state [5]
transition on STATIC to state [2]
transition on bitfield_list to state [181]
transition on VOLATILE to state [9]
transition on CONST to state [14]

-------------------
lalr_state [7]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [declaration ::= TYPEDEF (*) type name , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on type to state [179]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [8]: {
  [bitfield_value ::= EXTERN (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [9]: {
  [bitfield_value ::= VOLATILE (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [10]: {
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration_list ::= declaration_list (*) declaration , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [declaration ::= (*) TYPEDEF type name , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
  [$START ::= declaration_list (*) EOF , {EOF }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {EOF FUN VAR VOLATILE REGISTER TYPEDEF STRUCT STATIC EXTERN UNION CONST ENUM AUTO }]
}
transition on CONST to state [14]
transition on bitfield_list to state [12]
transition on AUTO to state [13]
transition on bitfield_value to state [11]
transition on VOLATILE to state [9]
transition on EXTERN to state [8]
transition on TYPEDEF to state [7]
transition on VAR to state [6]
transition on EOF to state [178]
transition on REGISTER to state [5]
transition on FUN to state [4]
transition on declaration to state [177]
transition on STATIC to state [2]
transition on ENUM to state [1]

-------------------
lalr_state [11]: {
  [bitfield_value ::= (*) REGISTER , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= bitfield_value (*) bitfield_list , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) EXTERN , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) AUTO , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) VOLATILE , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_list ::= (*) , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
  [bitfield_value ::= (*) STATIC , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
  [bitfield_value ::= (*) CONST , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}
transition on bitfield_value to state [11]
transition on EXTERN to state [8]
transition on AUTO to state [13]
transition on REGISTER to state [5]
transition on bitfield_list to state [176]
transition on STATIC to state [2]
transition on VOLATILE to state [9]
transition on CONST to state [14]

-------------------
lalr_state [12]: {
  [struct_or_union ::= (*) UNION , {ID }]
  [declaration ::= bitfield_list (*) struct_or_union name struct_or_union_declarator , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [struct_or_union ::= (*) STRUCT , {ID }]
}
transition on UNION to state [17]
transition on STRUCT to state [16]
transition on struct_or_union to state [15]

-------------------
lalr_state [13]: {
  [bitfield_value ::= AUTO (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [14]: {
  [bitfield_value ::= CONST (*) , {ID INT VOLATILE REGISTER STRUCT STATIC EXTERN DOUBLE UNION SHORT FLOAT CONST VOID LONG ENUM CHAR AUTO }]
}

-------------------
lalr_state [15]: {
  [Var ::= (*) ID , {LBRACE }]
  [declaration ::= bitfield_list struct_or_union (*) name struct_or_union_declarator , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) Var , {LBRACE }]
}
transition on Var to state [20]
transition on name to state [19]
transition on ID to state [18]

-------------------
lalr_state [16]: {
  [struct_or_union ::= STRUCT (*) , {ID }]
}

-------------------
lalr_state [17]: {
  [struct_or_union ::= UNION (*) , {ID }]
}

-------------------
lalr_state [18]: {
  [Var ::= ID (*) , {EOF error ID DECIMAL_LITERAL COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN TILDE BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [19]: {
  [declaration ::= bitfield_list struct_or_union name (*) struct_or_union_declarator , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [struct_or_union_declarator ::= (*) LBRACE struct_declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on struct_or_union_declarator to state [22]
transition on LBRACE to state [21]

-------------------
lalr_state [20]: {
  [name ::= Var (*) , {EOF error ID DECIMAL_LITERAL COMMA SEMICOLON LPAREN RPAREN LBRACE RBRACE PLUS MINUS ASSIGN IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [21]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [struct_declaration_list ::= (*) struct_declaration_list type name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [struct_or_union_declarator ::= LBRACE (*) struct_declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [struct_declaration_list ::= (*) type name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on type to state [31]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on struct_declaration_list to state [28]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [22]: {
  [declaration ::= bitfield_list struct_or_union name struct_or_union_declarator (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [23]: {
  [type_name ::= ENUM (*) ID , {ID COMMA RPAREN LBRACK TIMES }]
}
transition on ID to state [175]

-------------------
lalr_state [24]: {
  [type_name ::= INT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [25]: {
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= (*) TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [type ::= type_name (*) , {ID COMMA RPAREN }]
  [type_augments ::= (*) pointer_list brackets_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type_list expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type_list empty_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= (*) expression_array_type_list , {ID COMMA RPAREN }]
  [type ::= type_name (*) type_augments , {ID COMMA RPAREN }]
  [type_augments ::= (*) brackets_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= (*) pointer_list TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [brackets_list ::= (*) empty_array_type_list , {ID COMMA RPAREN }]
  [type_augments ::= (*) pointer_list , {ID COMMA RPAREN }]
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on LBRACK to state [49]
transition on TIMES to state [48]
transition on empty_array_type_list to state [47]
transition on expression_array_type_list to state [46]
transition on brackets_list to state [45]
transition on type_augments to state [44]
transition on expression_array_type to state [43]
transition on pointer_list to state [42]
transition on empty_array_type to state [41]

-------------------
lalr_state [26]: {
  [type_name ::= LONG (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [27]: {
  [type_name ::= VOID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [28]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [struct_declaration_list ::= struct_declaration_list (*) type name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [struct_or_union_declarator ::= LBRACE struct_declaration_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on RBRACE to state [38]
transition on type to state [37]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [29]: {
  [type_name ::= DOUBLE (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [30]: {
  [type_name ::= ID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [31]: {
  [struct_declaration_list ::= type (*) name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [Var ::= (*) ID , {SEMICOLON }]
  [name ::= (*) Var , {SEMICOLON }]
}
transition on Var to state [20]
transition on name to state [35]
transition on ID to state [18]

-------------------
lalr_state [32]: {
  [type_name ::= SHORT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [33]: {
  [type_name ::= FLOAT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [34]: {
  [type_name ::= CHAR (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [35]: {
  [struct_declaration_list ::= type name (*) SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}
transition on SEMICOLON to state [36]

-------------------
lalr_state [36]: {
  [struct_declaration_list ::= type name SEMICOLON (*) , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}

-------------------
lalr_state [37]: {
  [Var ::= (*) ID , {SEMICOLON }]
  [struct_declaration_list ::= struct_declaration_list type (*) name SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
  [name ::= (*) Var , {SEMICOLON }]
}
transition on Var to state [20]
transition on name to state [39]
transition on ID to state [18]

-------------------
lalr_state [38]: {
  [struct_or_union_declarator ::= LBRACE struct_declaration_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [39]: {
  [struct_declaration_list ::= struct_declaration_list type name (*) SEMICOLON , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}
transition on SEMICOLON to state [40]

-------------------
lalr_state [40]: {
  [struct_declaration_list ::= struct_declaration_list type name SEMICOLON (*) , {ID INT RBRACE DOUBLE SHORT FLOAT VOID LONG ENUM CHAR }]
}

-------------------
lalr_state [41]: {
  [empty_array_type_list ::= empty_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [42]: {
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [type_augments ::= pointer_list (*) brackets_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type_list expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type_list empty_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= (*) expression_array_type_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= pointer_list (*) TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [type_augments ::= pointer_list (*) , {ID COMMA RPAREN }]
  [brackets_list ::= (*) empty_array_type_list , {ID COMMA RPAREN }]
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on expression_array_type_list to state [46]
transition on TIMES to state [174]
transition on empty_array_type to state [41]
transition on LBRACK to state [49]
transition on expression_array_type to state [43]
transition on brackets_list to state [173]
transition on empty_array_type_list to state [47]

-------------------
lalr_state [43]: {
  [expression_array_type_list ::= expression_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [44]: {
  [type ::= type_name type_augments (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [45]: {
  [type_augments ::= brackets_list (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [46]: {
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [expression_array_type_list ::= expression_array_type_list (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= expression_array_type_list (*) , {ID COMMA RPAREN }]
}
transition on LBRACK to state [172]
transition on expression_array_type to state [171]

-------------------
lalr_state [47]: {
  [brackets_list ::= empty_array_type_list (*) , {ID COMMA RPAREN }]
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= empty_array_type_list (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
}
transition on empty_array_type to state [170]
transition on LBRACK to state [169]

-------------------
lalr_state [48]: {
  [pointer_list ::= TIMES (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [49]: {
  [unary_expression ::= (*) TILDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression_array_type ::= LBRACK (*) constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [conditional_expression ::= (*) logical_or_expression , {RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [constant_expression ::= (*) conditional_expression , {RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [empty_array_type ::= LBRACK (*) RBRACK , {ID COMMA RPAREN LBRACK }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_and_expression , {RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {RBRACK OR }]
  [and_expression ::= (*) equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on constant_expression to state [77]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on conditional_expression to state [62]
transition on LPAREN to state [61]
transition on and_expression to state [60]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]
transition on RBRACK to state [50]

-------------------
lalr_state [50]: {
  [empty_array_type ::= LBRACK RBRACK (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [51]: {
  [unary_expression ::= SIZEOF (*) LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on LPAREN to state [166]

-------------------
lalr_state [52]: {
  [postfix_expression ::= primary_expression (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [53]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= PLUS (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [165]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [54]: {
  [primary_expression ::= Var (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [55]: {
  [multiplicative_expression ::= cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [56]: {
  [primary_expression ::= DECIMAL_LITERAL (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [57]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= NOT (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [164]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [58]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= DECREMENT (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [163]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [59]: {
  [cast_expression ::= unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [60]: {
  [and_expression ::= and_expression (*) BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [exclusive_or_expression ::= and_expression (*) BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [exclusive_or_expression ::= and_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
}
transition on BWISEXOR to state [160]
transition on BITWISEAND to state [159]

-------------------
lalr_state [61]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= LPAREN (*) expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [157]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [62]: {
  [constant_expression ::= conditional_expression (*) , {COMMA RBRACK RBRACE }]
}

-------------------
lalr_state [63]: {
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [99]
transition on LSHIFT to state [98]

-------------------
lalr_state [64]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= TILDE (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [156]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [65]: {
  [postfix_expression ::= postfix_expression (*) DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= postfix_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression (*) LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on LPAREN to state [118]
transition on PERIOD to state [117]
transition on ARROW to state [116]
transition on INCREMENT to state [115]
transition on LBRACK to state [114]
transition on DECREMENT to state [113]

-------------------
lalr_state [66]: {
  [inclusive_or_expression ::= exclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
}

-------------------
lalr_state [67]: {
  [logical_and_expression ::= inclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [inclusive_or_expression ::= inclusive_or_expression (*) BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
}
transition on BWISEOR to state [89]

-------------------
lalr_state [68]: {
  [additive_expression ::= additive_expression (*) PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= additive_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on MINUS to state [102]
transition on PLUS to state [101]

-------------------
lalr_state [69]: {
  [equality_expression ::= equality_expression (*) EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [and_expression ::= equality_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression (*) NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on NEQ to state [110]
transition on EQ to state [109]

-------------------
lalr_state [70]: {
  [logical_and_expression ::= logical_and_expression (*) AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [logical_or_expression ::= logical_and_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
}
transition on AND to state [87]

-------------------
lalr_state [71]: {
  [relational_expression ::= relational_expression (*) LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= relational_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on GE to state [96]
transition on LE to state [95]
transition on GT to state [94]
transition on LT to state [93]

-------------------
lalr_state [72]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= INCREMENT (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [92]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [73]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= MINUS (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [91]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [74]: {
  [primary_expression ::= error (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [75]: {
  [logical_or_expression ::= logical_or_expression (*) OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [conditional_expression ::= logical_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}
transition on OR to state [85]

-------------------
lalr_state [76]: {
  [multiplicative_expression ::= multiplicative_expression (*) MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= multiplicative_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= multiplicative_expression (*) TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on TIMES to state [81]
transition on MODULUS to state [80]
transition on DIVIDE to state [79]

-------------------
lalr_state [77]: {
  [expression_array_type ::= LBRACK constant_expression (*) RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on RBRACK to state [78]

-------------------
lalr_state [78]: {
  [expression_array_type ::= LBRACK constant_expression RBRACK (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [79]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression DIVIDE (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [84]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [80]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression MODULUS (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [83]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [81]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression TIMES (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [82]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [82]: {
  [multiplicative_expression ::= multiplicative_expression TIMES cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [83]: {
  [multiplicative_expression ::= multiplicative_expression MODULUS cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [84]: {
  [multiplicative_expression ::= multiplicative_expression DIVIDE cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [85]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= logical_or_expression OR (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [86]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on and_expression to state [60]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [86]: {
  [logical_and_expression ::= logical_and_expression (*) AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [logical_or_expression ::= logical_or_expression OR logical_and_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
}
transition on AND to state [87]

-------------------
lalr_state [87]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= logical_and_expression AND (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [88]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on and_expression to state [60]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [88]: {
  [inclusive_or_expression ::= inclusive_or_expression (*) BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [logical_and_expression ::= logical_and_expression AND inclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
}
transition on BWISEOR to state [89]

-------------------
lalr_state [89]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= inclusive_or_expression BWISEOR (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on exclusive_or_expression to state [90]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on and_expression to state [60]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [90]: {
  [inclusive_or_expression ::= inclusive_or_expression BWISEOR exclusive_or_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
}

-------------------
lalr_state [91]: {
  [unary_expression ::= MINUS cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [92]: {
  [unary_expression ::= INCREMENT unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [93]: {
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [relational_expression ::= relational_expression LT (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [108]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [94]: {
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [relational_expression ::= relational_expression GT (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [107]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [95]: {
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [relational_expression ::= relational_expression LE (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [106]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [96]: {
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [relational_expression ::= relational_expression GE (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [97]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [97]: {
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression GE shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [99]
transition on LSHIFT to state [98]

-------------------
lalr_state [98]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= shift_expression LSHIFT (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [105]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [99]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [shift_expression ::= shift_expression RSHIFT (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on additive_expression to state [100]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [100]: {
  [shift_expression ::= shift_expression RSHIFT additive_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on MINUS to state [102]
transition on PLUS to state [101]

-------------------
lalr_state [101]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression PLUS (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on multiplicative_expression to state [104]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [55]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [102]: {
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression MINUS (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on Var to state [54]
transition on LPAREN to state [61]
transition on NOT to state [57]
transition on multiplicative_expression to state [103]
transition on primary_expression to state [52]
transition on DECIMAL_LITERAL to state [56]
transition on error to state [74]
transition on ID to state [18]
transition on DECREMENT to state [58]
transition on cast_expression to state [55]
transition on TILDE to state [64]
transition on postfix_expression to state [65]
transition on PLUS to state [53]
transition on unary_expression to state [59]
transition on SIZEOF to state [51]
transition on INCREMENT to state [72]
transition on MINUS to state [73]

-------------------
lalr_state [103]: {
  [multiplicative_expression ::= multiplicative_expression (*) MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression MINUS multiplicative_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on TIMES to state [81]
transition on MODULUS to state [80]
transition on DIVIDE to state [79]

-------------------
lalr_state [104]: {
  [multiplicative_expression ::= multiplicative_expression (*) MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [additive_expression ::= additive_expression PLUS multiplicative_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= multiplicative_expression (*) DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [multiplicative_expression ::= multiplicative_expression (*) TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on TIMES to state [81]
transition on MODULUS to state [80]
transition on DIVIDE to state [79]

-------------------
lalr_state [105]: {
  [additive_expression ::= additive_expression (*) PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression LSHIFT additive_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= additive_expression (*) MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on MINUS to state [102]
transition on PLUS to state [101]

-------------------
lalr_state [106]: {
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression LE shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [99]
transition on LSHIFT to state [98]

-------------------
lalr_state [107]: {
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression GT shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [99]
transition on LSHIFT to state [98]

-------------------
lalr_state [108]: {
  [shift_expression ::= shift_expression (*) RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression LT shift_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= shift_expression (*) LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on RSHIFT to state [99]
transition on LSHIFT to state [98]

-------------------
lalr_state [109]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= equality_expression EQ (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [112]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [110]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= equality_expression NEQ (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [111]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [111]: {
  [relational_expression ::= relational_expression (*) LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression NEQ relational_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on GE to state [96]
transition on LE to state [95]
transition on GT to state [94]
transition on LT to state [93]

-------------------
lalr_state [112]: {
  [relational_expression ::= relational_expression (*) LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression EQ relational_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= relational_expression (*) GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on GE to state [96]
transition on LE to state [95]
transition on GT to state [94]
transition on LT to state [93]

-------------------
lalr_state [113]: {
  [postfix_expression ::= postfix_expression DECREMENT (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [114]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RBRACK }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACK }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RBRACK }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RBRACK }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACK OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression LBRACK (*) expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RBRACK }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RBRACK }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [152]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [115]: {
  [postfix_expression ::= postfix_expression INCREMENT (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [116]: {
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression ARROW (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on Var to state [150]
transition on ID to state [18]

-------------------
lalr_state [117]: {
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression PERIOD (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on Var to state [149]
transition on ID to state [18]

-------------------
lalr_state [118]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression LPAREN (*) argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= postfix_expression LPAREN (*) RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [argument_expression_list ::= (*) assignment_expression , {COMMA RPAREN }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [argument_expression_list ::= (*) argument_expression_list COMMA assignment_expression , {COMMA RPAREN }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on argument_expression_list to state [123]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on RPAREN to state [120]
transition on assignment_expression to state [119]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [119]: {
  [argument_expression_list ::= assignment_expression (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [120]: {
  [postfix_expression ::= postfix_expression LPAREN RPAREN (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [121]: {
  [assignment_expression ::= unary_expression (*) BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= unary_expression (*) ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [cast_expression ::= unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on MODASSIGN to state [137]
transition on DIVASSIGN to state [136]
transition on RSHIFTASSIGN to state [135]
transition on ASSIGN to state [134]
transition on BWISEXORASSIGN to state [133]
transition on ADDASSIGN to state [132]
transition on LSHIFTASSIGN to state [131]
transition on SUBASSIGN to state [130]
transition on BWISEORASSIGN to state [129]
transition on MULASSIGN to state [128]
transition on BWISEANDASSIGN to state [127]

-------------------
lalr_state [122]: {
  [assignment_expression ::= conditional_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [123]: {
  [postfix_expression ::= postfix_expression LPAREN argument_expression_list (*) RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [argument_expression_list ::= argument_expression_list (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [125]
transition on COMMA to state [124]

-------------------
lalr_state [124]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [argument_expression_list ::= argument_expression_list COMMA (*) assignment_expression , {COMMA RPAREN }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [126]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [125]: {
  [postfix_expression ::= postfix_expression LPAREN argument_expression_list RPAREN (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [126]: {
  [argument_expression_list ::= argument_expression_list COMMA assignment_expression (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [127]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression BWISEANDASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on relational_expression to state [71]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [148]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [128]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression MULASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [147]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [129]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression BWISEORASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on relational_expression to state [71]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [146]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [130]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression SUBASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on relational_expression to state [71]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [145]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [131]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression LSHIFTASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [144]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [132]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression ADDASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [143]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [133]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression BWISEXORASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [142]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [134]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression ASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [141]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [135]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression RSHIFTASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [140]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [136]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression DIVASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on relational_expression to state [71]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [139]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [137]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= unary_expression MODASSIGN (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [138]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [138]: {
  [assignment_expression ::= unary_expression MODASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [139]: {
  [assignment_expression ::= unary_expression DIVASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [140]: {
  [assignment_expression ::= unary_expression RSHIFTASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [141]: {
  [assignment_expression ::= unary_expression ASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [142]: {
  [assignment_expression ::= unary_expression BWISEXORASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [143]: {
  [assignment_expression ::= unary_expression ADDASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [144]: {
  [assignment_expression ::= unary_expression LSHIFTASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [145]: {
  [assignment_expression ::= unary_expression SUBASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [146]: {
  [assignment_expression ::= unary_expression BWISEORASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [147]: {
  [assignment_expression ::= unary_expression MULASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [148]: {
  [assignment_expression ::= unary_expression BWISEANDASSIGN assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE }]
}

-------------------
lalr_state [149]: {
  [postfix_expression ::= postfix_expression PERIOD Var (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [150]: {
  [postfix_expression ::= postfix_expression ARROW Var (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [151]: {
  [expression ::= assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK }]
}

-------------------
lalr_state [152]: {
  [postfix_expression ::= postfix_expression LBRACK expression (*) RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RBRACK }]
}
transition on RBRACK to state [154]
transition on COMMA to state [153]

-------------------
lalr_state [153]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= expression COMMA (*) assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON RPAREN RBRACK OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON RPAREN RBRACK }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON RPAREN RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on relational_expression to state [71]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [155]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [154]: {
  [postfix_expression ::= postfix_expression LBRACK expression RBRACK (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [155]: {
  [expression ::= expression COMMA assignment_expression (*) , {COMMA SEMICOLON RPAREN RBRACK }]
}

-------------------
lalr_state [156]: {
  [unary_expression ::= TILDE cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [157]: {
  [primary_expression ::= LPAREN expression (*) RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [158]
transition on COMMA to state [153]

-------------------
lalr_state [158]: {
  [primary_expression ::= LPAREN expression RPAREN (*) , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}

-------------------
lalr_state [159]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= and_expression BITWISEAND (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [162]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [160]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [exclusive_or_expression ::= and_expression BWISEXOR (*) equality_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN RPAREN LBRACK RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR PERIOD MODULUS }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR }]
}
transition on multiplicative_expression to state [76]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on equality_expression to state [161]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [161]: {
  [exclusive_or_expression ::= and_expression BWISEXOR equality_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR }]
  [equality_expression ::= equality_expression (*) EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
  [equality_expression ::= equality_expression (*) NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR }]
}
transition on NEQ to state [110]
transition on EQ to state [109]

-------------------
lalr_state [162]: {
  [and_expression ::= and_expression BITWISEAND equality_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression (*) EQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [equality_expression ::= equality_expression (*) NEQ relational_expression , {COMMA SEMICOLON RPAREN RBRACK RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
}
transition on NEQ to state [110]
transition on EQ to state [109]

-------------------
lalr_state [163]: {
  [unary_expression ::= DECREMENT unary_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [164]: {
  [unary_expression ::= NOT cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [165]: {
  [unary_expression ::= PLUS cast_expression (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [166]: {
  [type_name ::= (*) ENUM ID , {RPAREN }]
  [type_name ::= (*) LONG , {RPAREN }]
  [type_name ::= (*) CHAR , {RPAREN }]
  [unary_expression ::= SIZEOF LPAREN (*) type_name RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [type_name ::= (*) DOUBLE , {RPAREN }]
  [type_name ::= (*) INT , {RPAREN }]
  [type_name ::= (*) VOID , {RPAREN }]
  [type_name ::= (*) ID , {RPAREN }]
  [type_name ::= (*) FLOAT , {RPAREN }]
  [type_name ::= (*) SHORT , {RPAREN }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [167]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [167]: {
  [unary_expression ::= SIZEOF LPAREN type_name (*) RPAREN , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}
transition on RPAREN to state [168]

-------------------
lalr_state [168]: {
  [unary_expression ::= SIZEOF LPAREN type_name RPAREN (*) , {COMMA SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
}

-------------------
lalr_state [169]: {
  [empty_array_type ::= LBRACK (*) RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on RBRACK to state [50]

-------------------
lalr_state [170]: {
  [empty_array_type_list ::= empty_array_type_list empty_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [171]: {
  [expression_array_type_list ::= expression_array_type_list expression_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [172]: {
  [unary_expression ::= (*) TILDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression_array_type ::= LBRACK (*) constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [conditional_expression ::= (*) logical_or_expression , {RBRACK }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [constant_expression ::= (*) conditional_expression , {RBRACK }]
  [exclusive_or_expression ::= (*) and_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {RBRACK AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_and_expression , {RBRACK OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {RBRACK EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {RBRACK OR }]
  [and_expression ::= (*) equality_expression , {RBRACK AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {RBRACK EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {LPAREN LBRACK RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {RBRACK AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {RBRACK EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {RBRACK PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on constant_expression to state [77]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on relational_expression to state [71]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on conditional_expression to state [62]
transition on LPAREN to state [61]
transition on and_expression to state [60]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [173]: {
  [type_augments ::= pointer_list brackets_list (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [174]: {
  [pointer_list ::= pointer_list TIMES (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [175]: {
  [type_name ::= ENUM ID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [176]: {
  [bitfield_list ::= bitfield_value bitfield_list (*) , {ID INT STRUCT DOUBLE UNION SHORT FLOAT VOID LONG ENUM CHAR }]
}

-------------------
lalr_state [177]: {
  [declaration_list ::= declaration_list declaration (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [178]: {
  [$START ::= declaration_list EOF (*) , {EOF }]
}

-------------------
lalr_state [179]: {
  [Var ::= (*) ID , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [declaration ::= TYPEDEF type (*) name , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) Var , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on Var to state [20]
transition on name to state [180]
transition on ID to state [18]

-------------------
lalr_state [180]: {
  [declaration ::= TYPEDEF type name (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [181]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [declaration ::= VAR bitfield_list (*) type name initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on type to state [182]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [182]: {
  [Var ::= (*) ID , {SEMICOLON ASSIGN }]
  [declaration ::= VAR bitfield_list type (*) name initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) Var , {SEMICOLON ASSIGN }]
}
transition on Var to state [20]
transition on name to state [183]
transition on ID to state [18]

-------------------
lalr_state [183]: {
  [initialization ::= (*) ASSIGN initializer , {SEMICOLON }]
  [declaration ::= VAR bitfield_list type name (*) initialization SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [initialization ::= (*) , {SEMICOLON }]
}
transition on ASSIGN to state [185]
transition on initialization to state [184]

-------------------
lalr_state [184]: {
  [declaration ::= VAR bitfield_list type name initialization (*) SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [194]

-------------------
lalr_state [185]: {
  [unary_expression ::= (*) TILDE cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initialization ::= ASSIGN (*) initializer , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {SEMICOLON }]
  [Var ::= (*) ID , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on initializer to state [188]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on relational_expression to state [71]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on LBRACE to state [187]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [186]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [186]: {
  [initializer ::= assignment_expression (*) , {COMMA SEMICOLON RBRACE }]
}

-------------------
lalr_state [187]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer_list ::= (*) initializer_list COMMA initializer , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [initializer ::= LBRACE (*) initializer_list RBRACE , {COMMA SEMICOLON RBRACE }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {COMMA RBRACE }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer_list ::= (*) initializer , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on initializer to state [190]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on initializer_list to state [189]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on LBRACE to state [187]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [186]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [188]: {
  [initialization ::= ASSIGN initializer (*) , {SEMICOLON }]
}

-------------------
lalr_state [189]: {
  [initializer_list ::= initializer_list (*) COMMA initializer , {COMMA RBRACE }]
  [initializer ::= LBRACE initializer_list (*) RBRACE , {COMMA SEMICOLON RBRACE }]
}
transition on RBRACE to state [192]
transition on COMMA to state [191]

-------------------
lalr_state [190]: {
  [initializer_list ::= initializer (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [191]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RBRACE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [initializer_list ::= initializer_list COMMA (*) initializer , {COMMA RBRACE }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {COMMA RBRACE }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RBRACE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RBRACE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RBRACE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on initializer to state [193]
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on LBRACE to state [187]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [186]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [192]: {
  [initializer ::= LBRACE initializer_list RBRACE (*) , {COMMA SEMICOLON RBRACE }]
}

-------------------
lalr_state [193]: {
  [initializer_list ::= initializer_list COMMA initializer (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [194]: {
  [declaration ::= VAR bitfield_list type name initialization SEMICOLON (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [195]: {
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [declaration ::= FUN bitfield_list (*) type name type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [declaration ::= FUN bitfield_list (*) type name parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on type to state [196]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [196]: {
  [Var ::= (*) ID , {LPAREN }]
  [declaration ::= FUN bitfield_list type (*) name parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [name ::= (*) Var , {LPAREN }]
  [declaration ::= FUN bitfield_list type (*) name type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on Var to state [20]
transition on name to state [197]
transition on ID to state [18]

-------------------
lalr_state [197]: {
  [declaration ::= FUN bitfield_list type name (*) parameters compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [parameters ::= (*) LPAREN parameter_list COMMA ELIPSES RPAREN , {LBRACE }]
  [type_parameters ::= (*) LPAREN parameter_type_list COMMA ELIPSES RPAREN , {SEMICOLON }]
  [parameters ::= (*) LPAREN parameter_list RPAREN , {LBRACE }]
  [type_parameters ::= (*) LPAREN parameter_type_list RPAREN , {SEMICOLON }]
  [declaration ::= FUN bitfield_list type name (*) type_parameters SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [parameters ::= (*) LPAREN RPAREN , {LBRACE }]
  [type_parameters ::= (*) LPAREN RPAREN , {SEMICOLON }]
}
transition on LPAREN to state [200]
transition on parameters to state [199]
transition on type_parameters to state [198]

-------------------
lalr_state [198]: {
  [declaration ::= FUN bitfield_list type name type_parameters (*) SEMICOLON , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [296]

-------------------
lalr_state [199]: {
  [declaration ::= FUN bitfield_list type name parameters (*) compound_statement , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on compound_statement to state [218]
transition on LBRACE to state [217]

-------------------
lalr_state [200]: {
  [parameters ::= LPAREN (*) parameter_list COMMA ELIPSES RPAREN , {LBRACE }]
  [parameter_type_list ::= (*) parameter_type_list COMMA type , {COMMA RPAREN }]
  [type ::= (*) type_name , {ID COMMA RPAREN }]
  [type_name ::= (*) SHORT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) ENUM ID , {ID COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN (*) RPAREN , {SEMICOLON }]
  [parameter_list ::= (*) parameter_list COMMA type name , {COMMA RPAREN }]
  [type_name ::= (*) VOID , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN (*) parameter_type_list RPAREN , {SEMICOLON }]
  [parameters ::= LPAREN (*) RPAREN , {LBRACE }]
  [type_name ::= (*) INT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) ID , {ID COMMA RPAREN LBRACK TIMES }]
  [parameters ::= LPAREN (*) parameter_list RPAREN , {LBRACE }]
  [parameter_type_list ::= (*) type , {COMMA RPAREN }]
  [type ::= (*) type_name type_augments , {ID COMMA RPAREN }]
  [type_name ::= (*) CHAR , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) DOUBLE , {ID COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN (*) parameter_type_list COMMA ELIPSES RPAREN , {SEMICOLON }]
  [parameter_list ::= (*) type name , {COMMA RPAREN }]
  [type_name ::= (*) LONG , {ID COMMA RPAREN LBRACK TIMES }]
}
transition on SHORT to state [32]
transition on parameter_list to state [204]
transition on FLOAT to state [33]
transition on CHAR to state [34]
transition on parameter_type_list to state [203]
transition on RPAREN to state [202]
transition on type to state [201]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [201]: {
  [Var ::= (*) ID , {COMMA RPAREN }]
  [parameter_list ::= type (*) name , {COMMA RPAREN }]
  [name ::= (*) Var , {COMMA RPAREN }]
  [parameter_type_list ::= type (*) , {COMMA RPAREN }]
}
transition on Var to state [20]
transition on name to state [216]
transition on ID to state [18]

-------------------
lalr_state [202]: {
  [parameters ::= LPAREN RPAREN (*) , {LBRACE }]
  [type_parameters ::= LPAREN RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [203]: {
  [type_parameters ::= LPAREN parameter_type_list (*) COMMA ELIPSES RPAREN , {SEMICOLON }]
  [parameter_type_list ::= parameter_type_list (*) COMMA type , {COMMA RPAREN }]
  [type_parameters ::= LPAREN parameter_type_list (*) RPAREN , {SEMICOLON }]
}
transition on RPAREN to state [212]
transition on COMMA to state [211]

-------------------
lalr_state [204]: {
  [parameter_list ::= parameter_list (*) COMMA type name , {COMMA RPAREN }]
  [parameters ::= LPAREN parameter_list (*) COMMA ELIPSES RPAREN , {LBRACE }]
  [parameters ::= LPAREN parameter_list (*) RPAREN , {LBRACE }]
}
transition on RPAREN to state [206]
transition on COMMA to state [205]

-------------------
lalr_state [205]: {
  [parameter_list ::= parameter_list COMMA (*) type name , {COMMA RPAREN }]
  [parameters ::= LPAREN parameter_list COMMA (*) ELIPSES RPAREN , {LBRACE }]
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on ELIPSES to state [208]
transition on type to state [207]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [206]: {
  [parameters ::= LPAREN parameter_list RPAREN (*) , {LBRACE }]
}

-------------------
lalr_state [207]: {
  [Var ::= (*) ID , {COMMA RPAREN }]
  [name ::= (*) Var , {COMMA RPAREN }]
  [parameter_list ::= parameter_list COMMA type (*) name , {COMMA RPAREN }]
}
transition on Var to state [20]
transition on name to state [210]
transition on ID to state [18]

-------------------
lalr_state [208]: {
  [parameters ::= LPAREN parameter_list COMMA ELIPSES (*) RPAREN , {LBRACE }]
}
transition on RPAREN to state [209]

-------------------
lalr_state [209]: {
  [parameters ::= LPAREN parameter_list COMMA ELIPSES RPAREN (*) , {LBRACE }]
}

-------------------
lalr_state [210]: {
  [parameter_list ::= parameter_list COMMA type name (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [211]: {
  [type_name ::= (*) ENUM ID , {COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN parameter_type_list COMMA (*) ELIPSES RPAREN , {SEMICOLON }]
  [type_name ::= (*) LONG , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) CHAR , {COMMA RPAREN LBRACK TIMES }]
  [type ::= (*) type_name , {COMMA RPAREN }]
  [parameter_type_list ::= parameter_type_list COMMA (*) type , {COMMA RPAREN }]
  [type_name ::= (*) DOUBLE , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) INT , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) VOID , {COMMA RPAREN LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {COMMA RPAREN }]
  [type_name ::= (*) ID , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) SHORT , {COMMA RPAREN LBRACK TIMES }]
}
transition on CHAR to state [34]
transition on FLOAT to state [33]
transition on SHORT to state [32]
transition on ELIPSES to state [214]
transition on type to state [213]
transition on ID to state [30]
transition on DOUBLE to state [29]
transition on VOID to state [27]
transition on LONG to state [26]
transition on type_name to state [25]
transition on INT to state [24]
transition on ENUM to state [23]

-------------------
lalr_state [212]: {
  [type_parameters ::= LPAREN parameter_type_list RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [213]: {
  [parameter_type_list ::= parameter_type_list COMMA type (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [214]: {
  [type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES (*) RPAREN , {SEMICOLON }]
}
transition on RPAREN to state [215]

-------------------
lalr_state [215]: {
  [type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [216]: {
  [parameter_list ::= type name (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [217]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [declaration_list ::= (*) declaration_list declaration , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [declaration_list ::= (*) declaration , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) declaration_list statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) declaration_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) TYPEDEF type name , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement_list statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on statement_list to state [239]
transition on DO to state [238]
transition on VAR to state [6]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on declaration to state [3]
transition on VOLATILE to state [9]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [235]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on ENUM to state [1]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on AUTO to state [13]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [229]
transition on expression to state [228]
transition on ID to state [18]
transition on bitfield_value to state [11]
transition on IF to state [227]
transition on PLUS to state [53]
transition on TYPEDEF to state [7]
transition on EXTERN to state [8]
transition on cast_expression to state [55]
transition on FUN to state [4]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on STATIC to state [2]
transition on TILDE to state [64]
transition on FOR to state [225]
transition on DECREMENT to state [58]
transition on MINUS to state [73]
transition on REGISTER to state [5]
transition on compound_statement to state [224]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on CONTINUE to state [222]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on CONST to state [14]
transition on declaration_list to state [219]
transition on INCREMENT to state [72]
transition on bitfield_list to state [12]

-------------------
lalr_state [218]: {
  [declaration ::= FUN bitfield_list type name parameters compound_statement (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [219]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [declaration_list ::= declaration_list (*) declaration , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) , {STRUCT UNION }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {STRUCT UNION }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= LBRACE declaration_list (*) statement_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) CONST , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) VOLATILE , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= LBRACE declaration_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [bitfield_value ::= (*) EXTERN , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) TYPEDEF type name , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) STATIC , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) bitfield_list struct_or_union name struct_or_union_declarator , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) AUTO , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [statement_list ::= (*) statement_list statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [bitfield_value ::= (*) REGISTER , {VOLATILE REGISTER STRUCT STATIC EXTERN UNION CONST AUTO }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on statement_list to state [294]
transition on DO to state [238]
transition on VAR to state [6]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on declaration to state [177]
transition on VOLATILE to state [9]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [293]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on ENUM to state [1]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on AUTO to state [13]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [229]
transition on expression to state [228]
transition on ID to state [18]
transition on bitfield_value to state [11]
transition on IF to state [227]
transition on PLUS to state [53]
transition on TYPEDEF to state [7]
transition on EXTERN to state [8]
transition on cast_expression to state [55]
transition on FUN to state [4]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on STATIC to state [2]
transition on TILDE to state [64]
transition on FOR to state [225]
transition on DECREMENT to state [58]
transition on MINUS to state [73]
transition on REGISTER to state [5]
transition on compound_statement to state [224]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on CONTINUE to state [222]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on CONST to state [14]
transition on INCREMENT to state [72]
transition on bitfield_list to state [12]

-------------------
lalr_state [220]: {
  [statement ::= iteration_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [221]: {
  [statement ::= jump_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [222]: {
  [jump_statement ::= CONTINUE (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [292]

-------------------
lalr_state [223]: {
  [primary_expression ::= Var (*) , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [labeled_statement ::= Var (*) COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on COLON to state [290]

-------------------
lalr_state [224]: {
  [statement ::= compound_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [225]: {
  [iteration_statement ::= FOR (*) LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR (*) LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [265]

-------------------
lalr_state [226]: {
  [expression_statement ::= SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [227]: {
  [selection_statement ::= IF (*) LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= IF (*) LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [259]

-------------------
lalr_state [228]: {
  [expression_statement ::= expression (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
}
transition on SEMICOLON to state [258]
transition on COMMA to state [153]

-------------------
lalr_state [229]: {
  [statement_list ::= statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [230]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [jump_statement ::= RETURN (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= RETURN (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [256]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on NOT to state [57]
transition on DECREMENT to state [58]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on SEMICOLON to state [255]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [231]: {
  [statement ::= selection_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [232]: {
  [jump_statement ::= BREAK (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [254]

-------------------
lalr_state [233]: {
  [Var ::= (*) ID , {SEMICOLON }]
  [jump_statement ::= GOTO (*) Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on Var to state [252]
transition on ID to state [18]

-------------------
lalr_state [234]: {
  [iteration_statement ::= WHILE (*) LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [248]

-------------------
lalr_state [235]: {
  [compound_statement ::= LBRACE RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [236]: {
  [statement ::= expression_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [237]: {
  [statement ::= labeled_statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [238]: {
  [statement ::= (*) iteration_statement , {WHILE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {WHILE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {WHILE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {WHILE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {WHILE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {WHILE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {WHILE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {WHILE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {WHILE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {WHILE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {WHILE }]
  [statement ::= (*) labeled_statement , {WHILE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {WHILE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= DO (*) statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {WHILE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {WHILE }]
  [statement ::= (*) compound_statement , {WHILE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {WHILE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {WHILE }]
  [statement ::= (*) expression_statement , {WHILE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {WHILE }]
  [statement ::= (*) selection_statement , {WHILE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {WHILE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [242]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [239]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= LBRACE statement_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [statement_list ::= statement_list (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [241]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [240]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [240]: {
  [statement_list ::= statement_list statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [241]: {
  [compound_statement ::= LBRACE statement_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [242]: {
  [iteration_statement ::= DO statement (*) WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on WHILE to state [243]

-------------------
lalr_state [243]: {
  [iteration_statement ::= DO statement WHILE (*) LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on LPAREN to state [244]

-------------------
lalr_state [244]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= DO statement WHILE LPAREN (*) expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [245]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [245]: {
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
  [iteration_statement ::= DO statement WHILE LPAREN expression (*) RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on RPAREN to state [246]
transition on COMMA to state [153]

-------------------
lalr_state [246]: {
  [iteration_statement ::= DO statement WHILE LPAREN expression RPAREN (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [247]

-------------------
lalr_state [247]: {
  [iteration_statement ::= DO statement WHILE LPAREN expression RPAREN SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [248]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= WHILE LPAREN (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [249]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [249]: {
  [iteration_statement ::= WHILE LPAREN expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [250]
transition on COMMA to state [153]

-------------------
lalr_state [250]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= WHILE LPAREN expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [251]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [251]: {
  [iteration_statement ::= WHILE LPAREN expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [252]: {
  [jump_statement ::= GOTO Var (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [253]

-------------------
lalr_state [253]: {
  [jump_statement ::= GOTO Var SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [254]: {
  [jump_statement ::= BREAK SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [255]: {
  [jump_statement ::= RETURN SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [256]: {
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
  [jump_statement ::= RETURN expression (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [257]
transition on COMMA to state [153]

-------------------
lalr_state [257]: {
  [jump_statement ::= RETURN expression SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [258]: {
  [expression_statement ::= expression SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [259]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN (*) expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [260]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [260]: {
  [selection_statement ::= IF LPAREN expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
  [selection_statement ::= IF LPAREN expression (*) RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on RPAREN to state [261]
transition on COMMA to state [153]

-------------------
lalr_state [261]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= IF LPAREN expression RPAREN (*) statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [262]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [262]: {
  [selection_statement ::= IF LPAREN expression RPAREN statement (*) ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [selection_statement ::= IF LPAREN expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on ELSE to state [263]

-------------------
lalr_state [263]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [selection_statement ::= IF LPAREN expression RPAREN statement ELSE (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [264]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [264]: {
  [selection_statement ::= IF LPAREN expression RPAREN statement ELSE statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [265]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN (*) expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [267]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on NOT to state [57]
transition on DECREMENT to state [58]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on SEMICOLON to state [266]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [266]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN SEMICOLON (*) expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON (*) expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN SEMICOLON (*) SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [281]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on SEMICOLON to state [280]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [267]: {
  [iteration_statement ::= FOR LPAREN expression (*) SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN expression (*) SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
  [iteration_statement ::= FOR LPAREN expression (*) SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [268]
transition on COMMA to state [153]

-------------------
lalr_state [268]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON (*) expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON (*) SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON (*) expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [270]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on SEMICOLON to state [269]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [269]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [277]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [270]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression (*) SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression (*) SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
}
transition on SEMICOLON to state [271]
transition on COMMA to state [153]

-------------------
lalr_state [271]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [273]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on RPAREN to state [272]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [272]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [276]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [273]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
}
transition on RPAREN to state [274]
transition on COMMA to state [153]

-------------------
lalr_state [274]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [275]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [275]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [276]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [277]: {
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on RPAREN to state [278]
transition on COMMA to state [153]

-------------------
lalr_state [278]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [279]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [279]: {
  [iteration_statement ::= FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [280]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on RPAREN to state [288]

-------------------
lalr_state [281]: {
  [expression ::= expression (*) COMMA assignment_expression , {COMMA SEMICOLON }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression (*) SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression (*) SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on SEMICOLON to state [282]
transition on COMMA to state [153]

-------------------
lalr_state [282]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA RPAREN }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RPAREN }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON (*) expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [relational_expression ::= (*) shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RPAREN AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [shift_expression ::= (*) additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) conditional_expression , {COMMA RPAREN }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [Var ::= (*) ID , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RPAREN OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RPAREN EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA RPAREN }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RPAREN OR }]
  [and_expression ::= (*) equality_expression , {COMMA RPAREN AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN RPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA RPAREN }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA RPAREN }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RPAREN AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RPAREN EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RPAREN PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on relational_expression to state [71]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on expression to state [284]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on LPAREN to state [61]
transition on conditional_expression to state [122]
transition on and_expression to state [60]
transition on unary_expression to state [121]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on assignment_expression to state [151]
transition on RPAREN to state [283]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [283]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [287]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [284]: {
  [expression ::= expression (*) COMMA assignment_expression , {COMMA RPAREN }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression (*) RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}
transition on RPAREN to state [285]
transition on COMMA to state [153]

-------------------
lalr_state [285]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [286]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [286]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [287]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [288]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON RPAREN (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [289]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [289]: {
  [iteration_statement ::= FOR LPAREN SEMICOLON SEMICOLON RPAREN statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [290]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= Var COLON (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [291]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [291]: {
  [labeled_statement ::= Var COLON statement (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [292]: {
  [jump_statement ::= CONTINUE SEMICOLON (*) , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [293]: {
  [compound_statement ::= LBRACE declaration_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [294]: {
  [statement ::= (*) iteration_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ADDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression RSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [statement ::= (*) jump_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [expression_statement ::= (*) SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression SUBASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) primary_expression , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [labeled_statement ::= (*) Var COLON statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA SEMICOLON AND OR }]
  [cast_expression ::= (*) unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression DIVASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [expression ::= (*) expression COMMA assignment_expression , {COMMA SEMICOLON }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA SEMICOLON EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) postfix_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= LBRACE declaration_list statement_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [compound_statement ::= (*) LBRACE declaration_list statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [selection_statement ::= (*) IF LPAREN expression RPAREN statement ELSE statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MULASSIGN assignment_expression , {COMMA SEMICOLON }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) GOTO Var SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [Var ::= (*) ID , {COMMA COLON SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [and_expression ::= (*) equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE statement_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA SEMICOLON OR }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) WHILE LPAREN expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression MODASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) CONTINUE SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) labeled_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA SEMICOLON AND OR BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE declaration_list RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA SEMICOLON }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [iteration_statement ::= (*) DO statement WHILE LPAREN expression RPAREN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEANDASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) BREAK SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) compound_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [compound_statement ::= (*) LBRACE RBRACE , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN expression SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) expression_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [assignment_expression ::= (*) conditional_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression BWISEXORASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [jump_statement ::= (*) RETURN SEMICOLON , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [statement ::= (*) selection_statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA SEMICOLON AND OR BWISEOR }]
  [unary_expression ::= (*) TILDE cast_expression , {COMMA SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN SUBASSIGN ADDASSIGN MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [statement_list ::= statement_list (*) statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression ASSIGN assignment_expression , {COMMA SEMICOLON }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA SEMICOLON PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [iteration_statement ::= (*) FOR LPAREN SEMICOLON expression SEMICOLON RPAREN statement , {error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK NOT CONTINUE SIZEOF RETURN GOTO DECREMENT INCREMENT TILDE }]
  [assignment_expression ::= (*) unary_expression LSHIFTASSIGN assignment_expression , {COMMA SEMICOLON }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA SEMICOLON EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA SEMICOLON LPAREN LBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN RSHIFTASSIGN LSHIFTASSIGN BWISEORASSIGN BWISEXORASSIGN RSHIFT LSHIFT DIVASSIGN ARROW SUBASSIGN DECREMENT ADDASSIGN INCREMENT MULASSIGN BWISEANDASSIGN MODASSIGN BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
}
transition on DO to state [238]
transition on labeled_statement to state [237]
transition on relational_expression to state [71]
transition on expression_statement to state [236]
transition on DECIMAL_LITERAL to state [56]
transition on multiplicative_expression to state [76]
transition on RBRACE to state [295]
transition on WHILE to state [234]
transition on GOTO to state [233]
transition on assignment_expression to state [151]
transition on inclusive_or_expression to state [67]
transition on LBRACE to state [217]
transition on and_expression to state [60]
transition on shift_expression to state [63]
transition on logical_and_expression to state [70]
transition on postfix_expression to state [65]
transition on BREAK to state [232]
transition on conditional_expression to state [122]
transition on selection_statement to state [231]
transition on error to state [74]
transition on unary_expression to state [121]
transition on RETURN to state [230]
transition on statement to state [240]
transition on expression to state [228]
transition on ID to state [18]
transition on IF to state [227]
transition on PLUS to state [53]
transition on cast_expression to state [55]
transition on exclusive_or_expression to state [66]
transition on equality_expression to state [69]
transition on logical_or_expression to state [75]
transition on SIZEOF to state [51]
transition on SEMICOLON to state [226]
transition on NOT to state [57]
transition on primary_expression to state [52]
transition on TILDE to state [64]
transition on DECREMENT to state [58]
transition on FOR to state [225]
transition on MINUS to state [73]
transition on compound_statement to state [224]
transition on CONTINUE to state [222]
transition on Var to state [223]
transition on LPAREN to state [61]
transition on jump_statement to state [221]
transition on iteration_statement to state [220]
transition on additive_expression to state [68]
transition on INCREMENT to state [72]

-------------------
lalr_state [295]: {
  [compound_statement ::= LBRACE declaration_list statement_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF ELSE WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [296]: {
  [declaration ::= FUN bitfield_list type name type_parameters SEMICOLON (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [297]: {
  [declaration ::= ENUM ID (*) LBRACE enumerator_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on LBRACE to state [298]

-------------------
lalr_state [298]: {
  [enumerator_list ::= (*) enumerator_list COMMA enumerator , {COMMA RBRACE }]
  [enumerator ::= (*) ID ASSIGN constant_expression , {COMMA RBRACE }]
  [enumerator_list ::= (*) enumerator , {COMMA RBRACE }]
  [declaration ::= ENUM ID LBRACE (*) enumerator_list RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
  [enumerator ::= (*) ID , {COMMA RBRACE }]
}
transition on enumerator to state [301]
transition on enumerator_list to state [300]
transition on ID to state [299]

-------------------
lalr_state [299]: {
  [enumerator ::= ID (*) ASSIGN constant_expression , {COMMA RBRACE }]
  [enumerator ::= ID (*) , {COMMA RBRACE }]
}
transition on ASSIGN to state [305]

-------------------
lalr_state [300]: {
  [enumerator_list ::= enumerator_list (*) COMMA enumerator , {COMMA RBRACE }]
  [declaration ::= ENUM ID LBRACE enumerator_list (*) RBRACE , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}
transition on RBRACE to state [303]
transition on COMMA to state [302]

-------------------
lalr_state [301]: {
  [enumerator_list ::= enumerator (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [302]: {
  [enumerator_list ::= enumerator_list COMMA (*) enumerator , {COMMA RBRACE }]
  [enumerator ::= (*) ID ASSIGN constant_expression , {COMMA RBRACE }]
  [enumerator ::= (*) ID , {COMMA RBRACE }]
}
transition on enumerator to state [304]
transition on ID to state [299]

-------------------
lalr_state [303]: {
  [declaration ::= ENUM ID LBRACE enumerator_list RBRACE (*) , {EOF error ID DECIMAL_LITERAL SEMICOLON LPAREN LBRACE RBRACE PLUS MINUS IF WHILE FOR DO BREAK FUN VAR VOLATILE NOT REGISTER CONTINUE TYPEDEF STRUCT STATIC SIZEOF RETURN EXTERN UNION CONST GOTO ENUM AUTO DECREMENT INCREMENT TILDE }]
}

-------------------
lalr_state [304]: {
  [enumerator_list ::= enumerator_list COMMA enumerator (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [305]: {
  [unary_expression ::= (*) TILDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression PERIOD Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [conditional_expression ::= (*) logical_or_expression , {COMMA RBRACE }]
  [and_expression ::= (*) and_expression BITWISEAND equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [relational_expression ::= (*) shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression TIMES cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) INCREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN argument_expression_list RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression MINUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) NOT cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression ARROW Var , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) DECIMAL_LITERAL , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [constant_expression ::= (*) conditional_expression , {COMMA RBRACE }]
  [exclusive_or_expression ::= (*) and_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression DIVIDE cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) DECREMENT unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LPAREN RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_and_expression ::= (*) logical_and_expression AND inclusive_or_expression , {COMMA RBRACE AND OR }]
  [equality_expression ::= (*) equality_expression EQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) SIZEOF LPAREN type_name RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [primary_expression ::= (*) LPAREN expression RPAREN , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [exclusive_or_expression ::= (*) and_expression BWISEXOR equality_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression GT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) multiplicative_expression MODULUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) PLUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression INCREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [enumerator ::= ID ASSIGN (*) constant_expression , {COMMA RBRACE }]
  [Var ::= (*) ID , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_and_expression , {COMMA RBRACE OR }]
  [equality_expression ::= (*) equality_expression NEQ relational_expression , {COMMA RBRACE EQ NEQ AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression RSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [cast_expression ::= (*) unary_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) primary_expression , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LE shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [unary_expression ::= (*) MINUS cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression DECREMENT , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [primary_expression ::= (*) error , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [logical_or_expression ::= (*) logical_or_expression OR logical_and_expression , {COMMA RBRACE OR }]
  [and_expression ::= (*) equality_expression , {COMMA RBRACE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [shift_expression ::= (*) shift_expression LSHIFT additive_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
  [multiplicative_expression ::= (*) cast_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [unary_expression ::= (*) postfix_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND MODULUS }]
  [postfix_expression ::= (*) postfix_expression LBRACK expression RBRACK , {COMMA LPAREN LBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT ARROW DECREMENT INCREMENT BWISEOR BWISEXOR PERIOD BITWISEAND MODULUS }]
  [inclusive_or_expression ::= (*) inclusive_or_expression BWISEOR exclusive_or_expression , {COMMA RBRACE AND OR BWISEOR }]
  [relational_expression ::= (*) relational_expression LT shift_expression , {COMMA RBRACE EQ NEQ LT LE GT GE AND OR BWISEOR BWISEXOR BITWISEAND }]
  [additive_expression ::= (*) additive_expression PLUS multiplicative_expression , {COMMA RBRACE PLUS MINUS EQ NEQ LT LE GT GE AND OR RSHIFT LSHIFT BWISEOR BWISEXOR BITWISEAND }]
}
transition on multiplicative_expression to state [76]
transition on constant_expression to state [306]
transition on logical_or_expression to state [75]
transition on error to state [74]
transition on MINUS to state [73]
transition on INCREMENT to state [72]
transition on logical_and_expression to state [70]
transition on equality_expression to state [69]
transition on relational_expression to state [71]
transition on additive_expression to state [68]
transition on inclusive_or_expression to state [67]
transition on exclusive_or_expression to state [66]
transition on postfix_expression to state [65]
transition on TILDE to state [64]
transition on shift_expression to state [63]
transition on ID to state [18]
transition on conditional_expression to state [62]
transition on LPAREN to state [61]
transition on and_expression to state [60]
transition on unary_expression to state [59]
transition on DECREMENT to state [58]
transition on NOT to state [57]
transition on DECIMAL_LITERAL to state [56]
transition on cast_expression to state [55]
transition on Var to state [54]
transition on PLUS to state [53]
transition on primary_expression to state [52]
transition on SIZEOF to state [51]

-------------------
lalr_state [306]: {
  [enumerator ::= ID ASSIGN constant_expression (*) , {COMMA RBRACE }]
}

-------------------
Closing files...
------- CUP v0.10k Parser Generation Summary -------
  0 errors and 3 warnings
  80 terminals, 55 non-terminals, and 165 productions declared, 
  producing 307 unique parse states.
  2 terminals declared but not used.
  0 non-terminals declared but not used.
  0 productions never reduced.
  1 conflict detected (3 expected).
  Code written to "Grm.java", and "sym.java".
---------------------------------------------------- (v0.10k)
